rov_info

        _cache_set(ckey, hits)
        out = hits[:k]
        _set_hits_telemetry(tel, hits, out)
        tel["elapsedSec"] = round(time.perf_counter() - t_start, 6)
        if telemetry is not None:
            telemetry.update(tel)
        return out

# ===== aimodel/file_read/web/fetch.py =====

# aimodel/file_read/web/fetch.py
from __future__ import annotations
import asyncio
from typing import Tuple, List, Optional, Dict, Any
import time
import httpx
from urllib.parse import urlparse

try:
    from readability import Document
except Exception:
    Document = None  # optional

try:
    from bs4 import BeautifulSoup
except Exception:
    BeautifulSoup = None  # optional

try:
    from selectolax.parser import HTMLParser
except Exception:
    HTMLParser = None  # optional

from ..core.settings import SETTINGS


def _req(key: str):
    return SETTINGS[key]

def _ua() -> str:
    return str(_req("web_fetch_user_agent"))

def _timeout() -> float:
    return float(_req("web_fetch_timeout_sec"))

def _max_chars() -> int:
    return int(_req("web_fetch_max_chars"))

def _max_bytes() -> int:
    return int(_req("web_fetch_max_bytes"))

def _max_parallel() -> int:
    return max(1, int(_req("web_fetch_max_parallel")))


# -------------------- Adaptive cooldown (generic, no host hardcoding) --------------------
# host -> (fail_count, cooldown_until_ts)
_BAD_HOSTS: Dict[str, Tuple[int, float]] = {}

def _now() -> float:
    return time.time()

def _host_of(u: str) -> str:
    try:
        return (urlparse(u).hostname or "").lower()
    except Exception:
        return ""

def _cooldown_secs(fails: int) -> float:
    # 15m, 30m, 60m, ... capped at 24h
    base = 15 * 60.0
    cap = 24 * 60 * 60.0
    return min(cap, base * (2 ** max(0, fails - 1)))

def _mark_bad(host: str) -> None:
    if not host:
        return
    fails, until = _BAD_HOSTS.get(host, (0, 0.0))
    fails += 1
    _BAD_HOSTS[host] = (fails, _now() + _cooldown_secs(fails))

def _mark_good(host: str) -> None:
    if not host:
        return
    if host in _BAD_HOSTS:
        fails, until = _BAD_HOSTS[host]
        fails = max(0, fails - 1)
        if fails == 0:
            _BAD_HOSTS.pop(host, None)
        else:
            _BAD_HOSTS[host] = (fails, _now() + _cooldown_secs(fails))

def _is_on_cooldown(host: str) -> bool:
    ent = _BAD_HOSTS.get(host)
    return bool(ent and ent[1] > _now())
# ----------------------------------------------------------------------------------------


async def _read_capped_bytes(resp: httpx.Response, cap_bytes: int) -> bytes:
    out = bytearray()
    async for chunk in resp.aiter_bytes():
        if not chunk:
            continue
        remaining = cap_bytes - len(out)
        if remaining <= 0:
            break
        out.extend(chunk[:remaining])
        if len(out) >= cap_bytes:
            break
    return bytes(out)


def _extract_text_from_html(raw_html: str, url: str) -> str:
    html = raw_html or ""
    # Try readability first (often best for article-like pages)
    if Document is not None:
        try:
            doc = Document(html)
            summary_html = doc.summary(html_partial=True) or ""
            if summary_html:
                if BeautifulSoup is not None:
                    soup = BeautifulSoup(summary_html, "lxml")
                    txt = soup.get_text(" ", strip=True)
                    if txt:
                        return txt
        except Exception:
            pass
    # Try selectolax (fast, robust)
    if HTMLParser is not None:
        try:
            tree = HTMLParser(html)
            for bad in ("script", "style", "noscript"):
                for n in tree.tags(bad):
                    n.decompose()
            txt = tree.body.text(separator=" ", strip=True) if tree.body else tree.text(separator=" ", strip=True)
            if txt:
                return txt
        except Exception:
            pass
    # Fallback to BeautifulSoup full parse
    if BeautifulSoup is not None:
        try:
            soup = BeautifulSoup(html, "lxml")
            for s in soup(["script", "style", "noscript"]):
                s.extract()
            txt = soup.get_text(" ", strip=True)
            if txt:
                return txt
        except Exception:
            pass
    # Last resort: return raw html (will be trimmed by char cap)
    return html


async def fetch_clean(
    url: str,
    timeout_s: Optional[float] = None,
    max_chars: Optional[int] = None,
    max_bytes: Optional[int] = None,
    telemetry: Optional[Dict[str, Any]] = None,
) -> Tuple[str, int, str]:
    t0 = time.perf_counter()
    timeout = _timeout() if timeout_s is None else float(timeout_s)
    cap_chars = _max_chars() if max_chars is None else int(max_chars)
    cap_bytes = _max_bytes() if max_bytes is None else int(max_bytes)

    headers = {"User-Agent": _ua()}
    async with httpx.AsyncClient(follow_redirects=True, timeout=timeout, headers=headers) as client:
        r = await client.get(url)
        r.raise_for_status()
        ctype = (r.headers.get("content-type") or "").lower()

        raw_bytes = await _read_capped_bytes(r, cap_bytes)
        enc = r.encoding or "utf-8"
        raw_text = raw_bytes.decode(enc, errors="ignore")
        txt = _extract_text_from_html(raw_text, str(r.url))
        txt = (txt or "").strip().replace("\r", "")
        if len(txt) > cap_chars:
            txt = txt[:cap_chars]

        # Generic usefulness test: skip non-HTML or extremely short bodies
        MIN_USEFUL_CHARS = 80
        host_final = _host_of(str(r.url))
        if ("text/html" not in ctype) or (len(txt) < MIN_USEFUL_CHARS):
            _mark_bad(host_final)
        else:
            _mark_good(host_final)

        if telemetry is not None:
            telemetry.update({
                "reqUrl": url,
                "finalUrl": str(r.url),
                "status": int(r.status_code),
                "elapsedSec": round(time.perf_counter() - t0, 6),
                "bytes": len(raw_bytes),
                "chars": len(txt),
                "timeoutSec": timeout,
                "capBytes": cap_bytes,
                "capChars": cap_chars,
                "contentType": ctype,
                "cooldownFails": _BAD_HOSTS.get(host_final, (0, 0.0))[0] if host_final in _BAD_HOSTS else 0,
            })
        return (str(r.url), r.status_code, txt)


async def fetch_many(
    urls: List[str],
    per_timeout_s: Optional[float] = None,
    cap_chars: Optional[int] = None,
    cap_bytes: Optional[int] = None,
    max_parallel: Optional[int] = None,
    telemetry: Optional[Dict[str, Any]] = None,
):
    t_total0 = time.perf_counter()
    sem = asyncio.Semaphore(_max_parallel() if max_parallel is None else int(max_parallel))
    tel_items: List[Dict[str, Any]] = []

    async def _one(u: str):
        item_tel: Dict[str, Any] = {"reqUrl": u}
        host = _host_of(u)

        # Skip hosts currently on adaptive cooldown (generic, no lists)
        if _is_on_cooldown(host):
            item_tel.update({
                "ok": False,
                "skipped": True,
                "skipReason": "cooldown",
                "host": host,
            })
            tel_items.append(item_tel)
            return u, None

        t0 = time.perf_counter()
        async with sem:
            try:
                res = await fetch_clean(
                    u,
                    timeout_s=per_timeout_s,
                    max_chars=cap_chars,
                    max_bytes=cap_bytes,
                    telemetry=item_tel,
                )
                item_tel.setdefault("elapsedSec", round(time.perf_counter() - t0, 6))
                item_tel["ok"] = True
                item_tel["host"] = host
                tel_items.append(item_tel)
                return u, res
            except Exception as e:
                _mark_bad(host)  # network/HTTP error counts as a fail
                item_tel.update({
                    "ok": False,
                    "errorType": type(e).__name__,
                    "errorMsg": str(e),
                    "elapsedSec": round(time.perf_counter() - t0, 6),
                    "timeoutSec": (float(per_timeout_s) if per_timeout_s is not None else _timeout()),
                    "capBytes": (int(cap_bytes) if cap_bytes is not None else _max_bytes()),
                    "capChars": (int(cap_chars) if cap_chars is not None else _max_chars()),
                    "host": host,
                })
                tel_items.append(item_tel)
                return u, None

    tasks = [_one(u) for u in urls]
    results = await asyncio.gather(*tasks)

    if telemetry is not None:
        ok_cnt = sum(1 for it in tel_items if it.get("ok"))
        telemetry.update({
            "totalSec": round(time.perf_counter() - t_total0, 6),
            "requested": len(urls),
            "ok": ok_cnt,
            "miss": len(urls) - ok_cnt,
            "items": tel_items,
            "settings": {
                "userAgent": _ua(),
                "defaultTimeoutSec": _timeout(),
                "defaultCapChars": _max_chars(),
                "defaultCapBytes": _max_bytes(),
                "maxParallel": _max_parallel() if max_parallel is None else int(max_parallel),
            },
        })

    return results

# ===== aimodel/file_read/web/orchestrator.py =====

from __future__ import annotations
from typing import List, Tuple, Optional, Dict, Any
import time
from collections import defaultdict

from .brave import BraveProvider
from .provider import SearchHit
from .orchestrator_common import (
    _as_int, _as_float, _as_bool, _as_str,
    condense_doc, content_quality_score,
    _dedupe_by_host, score_hit, _head_tail,
    _fetch_round, _host,   # NOTE: make sure _host is imported
)
from ..core.request_ctx import get_x_id


async def build_web_block(query: str, k: Optional[int] = None, per_url_timeout_s: Optional[float] = None) -> Tuple[Optional[str], Dict[str, Any]]:
    tel: Dict[str, Any] = {"query": (query or "").strip()}
    cfg_k               = (int(k) if k is not None else _as_int("web_orch_default_k"))
    total_char_budget   = _as_int("web_orch_total_char_budget")
    per_doc_budget      = _as_int("web_orch_per_doc_char_budget")
    max_parallel        = _as_int("web_orch_max_parallel_fetch")
    overfetch_factor    = _as_float("web_orch_overfetch_factor")
    overfetch_min_extra = _as_int("web_orch_overfetch_min_extra")
    enable_js_retry     = _as_bool("web_orch_enable_js_retry")
    js_avg_q_thresh     = _as_float("web_orch_js_retry_avg_q")
    js_low_q_thresh     = _as_float("web_orch_js_retry_low_q")
    js_lowish_ratio     = _as_float("web_orch_js_retry_lowish_ratio")
    js_timeout_add      = _as_float("web_orch_js_retry_timeout_add")
    js_timeout_cap      = _as_float("web_orch_js_retry_timeout_cap")
    js_parallel_delta   = _as_int("web_orch_js_retry_parallel_delta")
    js_min_parallel     = _as_int("web_orch_js_retry_min_parallel")
    header_tpl          = _as_str("web_block_header")
    sep_str             = _as_str("web_orch_block_separator")
    min_chunk_after     = _as_int("web_orch_min_chunk_after_shrink")
    min_block_reserve   = _as_int("web_orch_min_block_reserve")
    per_timeout = (float(per_url_timeout_s) if per_url_timeout_s is not None else _as_float("web_fetch_timeout_sec"))
    start_time = time.perf_counter()

    provider = BraveProvider()
    # widen search result pool a bit for better host variety
    overfetch = max(cfg_k + overfetch_min_extra, int(round(cfg_k * overfetch_factor)))
    tel["search"] = {"requestedK": cfg_k, "overfetch": overfetch}
    t0 = time.perf_counter()
    try:
        hits: List[SearchHit] = await provider.search(query, k=overfetch, telemetry=tel["search"], xid=get_x_id())
    except Exception as e:
        tel["error"] = {"stage": "search", "type": type(e).__name__, "msg": str(e)}
        tel["elapsedSec"] = round(time.perf_counter() - start_time, 6)
        print("[web-block] (empty) due to search error:", tel["error"])
        return None, tel
    tel["search"]["elapsedSecTotal"] = round(time.perf_counter() - t0, 6)

    if not hits:
        tel["elapsedSec"] = round(time.perf_counter() - start_time, 6)
        print("[web-block] (empty) — no hits")
        return None, tel

    # score & keep uniques by URL
    seen_urls = set()
    scored: List[Tuple[int, SearchHit]] = []
    for h in hits:
        u = (h.url or "").strip()
        if not u or u in seen_urls:
            continue
        seen_urls.add(u)
        s = score_hit(h, query)
        scored.append((s, h))
    tel["scoring"] = {"inputHits": len(hits), "scored": len(scored)}

    if not scored:
        tel["elapsedSec"] = round(time.perf_counter() - start_time, 6)
        print("[web-block] (empty) — no scored hits")
        return None, tel

    # IMPORTANT: dedupe by host to a PREFETCH set (larger than k) to increase variety
    prefetch = max(cfg_k * 2, cfg_k + 6)
    top_hits = _dedupe_by_host(scored, prefetch)
    tel["scoring"]["picked"] = len(top_hits)
    urls = [h.url for h in top_hits]
    meta = [(h.title or h.url, h.url) for h in top_hits]

    # fetch round 1
    t_f = time.perf_counter()
    tel["fetch1"] = {}
    results = await _fetch_round(
        urls, meta, per_url_timeout_s=per_timeout, max_parallel=max_parallel, use_js=False, telemetry=tel["fetch1"]
    )
    tel["fetch1"]["roundSec"] = round(time.perf_counter() - t_f, 6)

    texts: List[Tuple[str, str, str]] = []
    quality_scores: List[float] = []
    for original_url, res in results:
        if not res:
            continue
        final_url, status, text = res
        title = next((t for (t, u) in meta if u == original_url), final_url)
        qscore = content_quality_score(text or "")
        quality_scores.append(qscore)
        if text:
            texts.append((title, final_url, text))
    tel["fetch1"]["docs"] = {"ok": len(texts), "qAvg": (sum(quality_scores)/len(quality_scores) if quality_scores else 0.0)}

    # optional JS retry
    try_js = False
    if enable_js_retry and quality_scores:
        avg_q = sum(quality_scores) / len(quality_scores)
        lowish = sum(1 for q in quality_scores if q < js_low_q_thresh)
        if avg_q < js_avg_q_thresh or (lowish / max(1, len(quality_scores))) >= js_lowish_ratio:
            try_js = True
        tel["jsRetry"] = {
            "considered": True, "triggered": try_js,
            "avgQ": round(avg_q, 4),
            "lowishRatio": round((lowish / max(1, len(quality_scores))) * 1.0, 4),
            "thresholds": {"avg": js_avg_q_thresh, "low": js_low_q_thresh, "ratio": js_lowish_ratio},
        }
    else:
        tel["jsRetry"] = {"considered": bool(enable_js_retry), "triggered": False}

    if try_js:
        js_timeout   = min(per_timeout + js_timeout_add, js_timeout_cap)
        js_parallel  = max(js_min_parallel, max_parallel + js_parallel_delta)
        tel["fetch2"] = {"timeoutSec": js_timeout, "maxParallel": js_parallel}
        results_js = await _fetch_round(
            urls, meta, per_url_timeout_s=js_timeout, max_parallel=js_parallel, use_js=True, telemetry=tel["fetch2"]
        )
        texts_js: List[Tuple[str, str, str]] = []
        for original_url, res in results_js:
            if not res:
                continue
            final_url, status, text = res
            title = next((t for (t, u) in meta if u == original_url), final_url)
            if text:
                texts_js.append((title, final_url, text))
        if texts_js:
            texts = texts_js

    if not texts:
        tel["elapsedSec"] = round(time.perf_counter() - start_time, 6)
        print("[web-block] (empty) — no fetched texts")
        return None, tel

    # sort by content quality (generic)
    texts.sort(key=lambda t: content_quality_score(t[2]), reverse=True)

    # ====== PER-HOST QUOTA ASSEMBLY ======
    # group fetched docs by host
    by_host: Dict[str, List[Tuple[str, str, str]]] = defaultdict(list)
    for title, url, text in texts:
        by_host[_host(url)].append((title, url, text))

    # keep each host's best doc first
    for h in by_host:
        by_host[h].sort(key=lambda x: content_quality_score(x[2]), reverse=True)

    # order hosts by the strength of their best doc
    hosts_ordered = sorted(by_host.keys(), key=lambda h: content_quality_score(by_host[h][0][2]), reverse=True)

    header = header_tpl.format(query=query)
    sep = sep_str
    available = max(min_block_reserve, total_char_budget - len(header) - len(sep))

    # compute a fair per-host quota so no site can hog the whole block
    min_hosts = max(1, min(_as_int("web_orch_min_hosts"), len(hosts_ordered))) if "web_orch_min_hosts" in globals() or "web_orch_min_hosts" in locals() else 3
    # equal-share starting point; clamp by per_doc_budget
    per_host_quota = max(min_chunk_after * 2, available // max(min_hosts, cfg_k))
    per_host_quota = min(per_host_quota, per_doc_budget)

    block_parts: List[str] = []
    used = 0
    included_hosts: List[str] = []

    # pass 1: guarantee at least one chunk per top hosts within their quota
    for h in hosts_ordered:
        title, url, text = by_host[h][0]
        chunk = condense_doc(title, url, text, max_chars=per_host_quota)
        sep_len = len(sep) if block_parts else 0
        if used + sep_len + len(chunk) > available:
            rem = available - used - sep_len
            if rem > min_chunk_after:
                chunk = _head_tail(chunk, rem)
            else:
                break
        block_parts.append(chunk)
        included_hosts.append(h)
        used += sep_len + len(chunk)
        if len(included_hosts) >= min_hosts and used >= int(available * 0.66):
            # decent diversity; move on to optional extras
            break

    # pass 2: fill remaining space with next-best docs across hosts (still capped by per_doc_budget)
    # build a round-robin of second-best, third-best, ...
    layer = 1
    while used < available:
        added_any = False
        for h in hosts_ordered:
            if layer >= len(by_host[h]):
                continue
            title, url, text = by_host[h][layer]
            sep_len = len(sep) if block_parts else 0
            chunk = condense_doc(title, url, text, max_chars=per_doc_budget)
            if used + sep_len + len(chunk) > available:
                rem = available - used - sep_len
                if rem <= min_chunk_after:
                    continue
                chunk = _head_tail(chunk, rem)
                if used + sep_len + len(chunk) > available:
                    continue
            block_parts.append(chunk)
            used += sep_len + len(chunk)
            added_any = True
            if used >= available:
                break
        if not added_any:
            break
        layer += 1
    # ====== /PER-HOST QUOTA ASSEMBLY ======

    body = sep.join(block_parts)
    block = f"{header}{sep}{body}" if body else header

    tel["assembly"] = {
        "chunksPicked": len(block_parts),
        "chars": len(block),
        "available": available,
        "headerChars": len(header),
        "hostsIncluded": len(included_hosts),
        "perHostQuota": per_host_quota,
    }
    tel["elapsedSec"] = round(time.perf_counter() - start_time, 6)

    # Always print what is being sent
    print("[web-block] -------- BEGIN --------")
    print(block)
    print("[web-block] --------  END  --------")
    try:
        srcs = [{"title": t, "url": u} for (t, u, _) in texts[:10]]
        print("[web-block] sources:", srcs)
    except Exception as _e:
        print("[web-block] sources: <unavailable>", str(_e))

    return block, tel

# ===== aimodel/file_read/web/orchestrator_common.py =====

# aimodel/file_read/web/orchestrator_common.py
from __future__ import annotations
from typing import List, Tuple, Optional, Dict, Any
from urllib.parse import urlparse
import re
from ..utils.text import clean_ws
from ..core.settings import SETTINGS
from .provider import SearchHit
from .fetch import fetch_many

def _req(key: str):
    return SETTINGS[key]

def _as_int(key: str) -> int: return int(_req(key))
def _as_float(key: str) -> float: return float(_req(key))
def _as_bool(key: str) -> bool: return bool(_req(key))
def _as_str(key: str) -> str:
    v = _req(key)
    return "" if v is None else str(v)

def _host(url: str) -> str:
    h = (urlparse(url).hostname or "").lower()
    pref = _as_str("web_orch_www_prefix")
    return h[len(pref):] if pref and h.startswith(pref) else h

def _tokens(s: str) -> List[str]:
    return re.findall(r"\w+", (s or "").lower())

def _head_tail(text: str, max_chars: int) -> str:
    t = text or ""
    if max_chars <= 0 or len(t) <= max_chars:
        return clean_ws(t)

    ellipsis = _as_str("web_orch_ellipsis")
    # 40% head, 20% middle, 40% tail (generic)
    reserve = len(ellipsis) * 2
    avail = max(0, max_chars - reserve)
    if avail <= 0:
        return clean_ws(t[:max_chars])

    head_len = max(1, int(avail * 0.4))
    mid_len  = max(1, int(avail * 0.2))
    tail_len = max(1, avail - head_len - mid_len)

    n = len(t)
    # head
    h0, h1 = 0, min(head_len, n)
    head = t[h0:h1]

    # middle (centered)
    m0 = max(0, (n // 2) - (mid_len // 2))
    m1 = min(n, m0 + mid_len)
    # ensure middle starts after head if they overlap heavily
    if m0 < h1 and (h1 + mid_len) <= n:
        m0, m1 = h1, min(n, h1 + mid_len)
    mid = t[m0:m1]

    # tail
    t0 = max(m1, n - tail_len)  # avoid overlapping mid/tail
    tail = t[t0:n] if tail_len > 0 else ""

    return clean_ws(head + ellipsis + mid + ellipsis + tail)

def condense_doc(title: str, url: str, text: str, *, max_chars: int) -> str:
    body = _head_tail(text or "", max_chars)
    safe_title = clean_ws(title or url)
    bullet = _as_str("web_orch_bullet_prefix") or "- "
    indent = _as_str("web_orch_indent_prefix") or "  "
    return f"{bullet}{safe_title}\n{indent}{url}\n{indent}{body}"

def score_hit(hit: SearchHit, query: str) -> int:
    w_exact = _as_int("web_orch_score_w_exact")
    w_substr = _as_int("web_orch_score_w_substr")
    w_title_full = _as_int("web_orch_score_w_title_full")
    w_title_part = _as_int("web_orch_score_w_title_part")
    w_snip_touch = _as_int("web_orch_score_w_snip_touch")
    score = 0
    q = (query or "").strip().lower()
    title = (hit.title or "").strip()
    snippet = (hit.snippet or "").strip()
    title_l = title.lower()
    snip_l = snippet.lower()
    if q:
        if title_l == q:
            score += w_exact
        elif q in title_l:
            score += w_substr
    qtoks = _tokens(q)
    if qtoks:
        cov_title = sum(1 for t in qtoks if t in title_l)
        if cov_title == len(qtoks):
            score += w_title_full
        elif cov_title > 0:
            score += w_title_part
        if any(t in snip_l for t in qtoks):
            score += w_snip_touch
    return score

def _type_ratio(text: str, sub: str) -> float:
    if not text:
        return 1.0
    cnt = text.lower().count(sub)
    return float(cnt) / max(1, len(text))

def content_quality_score(text: str) -> float:
    if not text:
        return 0.0
    t = text.strip()
    n = len(t)
    len_div = _as_float("web_orch_q_len_norm_divisor")
    w_len = _as_float("web_orch_q_len_weight")
    w_div = _as_float("web_orch_q_diversity_weight")
    length_score = min(1.0, n / len_div) if len_div > 0 else 0.0
    toks = _tokens(t)
    if not toks:
        return 0.1 * length_score
    uniq = len(set(toks))
    diversity = uniq / max(1.0, float(len(toks)))
    pen = 0.0
    for rule in _req("web_orch_q_penalties"):
        token = str(rule.get("token") or "")
        mult = float(rule.get("mult") or 0.0)
        cap = float(rule.get("cap") or 1.0)
        pen += min(cap, _type_ratio(t, token) * mult)
    raw = (w_len * length_score) + (w_div * diversity) - pen
    return max(0.0, min(1.0, raw))

def _dedupe_by_host(scored_hits: List[Tuple[int, SearchHit]], k: int) -> List[SearchHit]:
    picked: List[SearchHit] = []
    seen_hosts = set()
    for s, h in sorted(scored_hits, key=lambda x: x[0], reverse=True):
        u = (h.url or "").strip()
        if not u:
            continue
        host = _host(u)
        if host in seen_hosts:
            continue
        seen_hosts.add(host)
        picked.append(h)
        if len(picked) >= k:
            break
    return picked

async def _fetch_round(
    urls: List[str],
    meta: List[Tuple[str, str]],
    per_url_timeout_s: float,
    max_parallel: int,
    use_js: bool = False,
    telemetry: Optional[Dict[str, Any]] = None,
) -> List[Tuple[str, Optional[Tuple[str, int, str]]]]:
    fetch_fn = fetch_many
    if use_js:
        try:
            from . import fetch as _fetch_mod
            fetch_fn = getattr(_fetch_mod, "fetch_many_js", fetch_many)
        except Exception:
            fetch_fn = fetch_many
    cap_mult = _as_float("web_orch_fetch_cap_multiplier")
    per_doc_budget = _as_int("web_orch_per_doc_char_budget")
    fetch_max_chars = _as_int("web_fetch_max_chars")
    per_doc_cap = min(int(per_doc_budget * cap_mult), fetch_max_chars)

    results = await fetch_fn(
        urls,
        per_timeout_s=per_url_timeout_s,
        cap_chars=per_doc_cap,
        max_parallel=max_parallel,
        telemetry=telemetry,
    )
    return results

# ===== aimodel/file_read/web/provider.py =====

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class SearchHit:
    title: str
    url: str
    snippet: Optional[str] = None
    rank: int = 0

class SearchProvider:
    async def search(self, query: str, k: int = 3) -> List[SearchHit]:
        raise NotImplementedError

# ===== aimodel/file_read/web/query_summarizer.py =====

# aimodel/file_read/web/query_summarizer.py
from __future__ import annotations
from typing import Any, Iterable, Dict, Tuple
import re, time
from ..core.settings import SETTINGS
from ..utils.streaming import safe_token_count_messages

def _tokens(s: str) -> set[str]:
    return set(re.findall(r"\w+", (s or "").lower()))

def _as_list(v) -> list:
    if v is None:
        return []
    if isinstance(v, (list, tuple)):
        return list(v)
    return [v]

def summarize_query(llm: Any, user_text: str) -> Tuple[str, Dict[str, Any]]:
    telemetry: Dict[str, Any] = {}
    txt = (user_text or "").strip()

    bypass_enabled = SETTINGS.get("query_sum_bypass_short_enabled")
    short_chars = SETTINGS.get("query_sum_short_max_chars")
    short_words = SETTINGS.get("query_sum_short_max_words")
    if bypass_enabled is True and isinstance(short_chars, int) and isinstance(short_words, int):
        if len(txt) <= short_chars and len(txt.split()) <= short_words:
            telemetry.update({"bypass": True})
            return txt, telemetry
    telemetry.update({"bypass": False})

    prompt = SETTINGS.get("query_sum_prompt")
    if isinstance(prompt, str) and "{text}" in prompt:
        params = {}
        max_tokens = SETTINGS.get("query_sum_max_tokens")
        if isinstance(max_tokens, int):
            params["max_tokens"] = max_tokens
        temperature = SETTINGS.get("query_sum_temperature")
        if isinstance(temperature, (int, float)):
            params["temperature"] = float(temperature)
        top_p = SETTINGS.get("query_sum_top_p")
        if isinstance(top_p, (int, float)):
            params["top_p"] = float(top_p)
        stops = _as_list(SETTINGS.get("query_sum_stop"))
        if stops:
            params["stop"] = [str(s) for s in stops if isinstance(s, str)]
        params["stream"] = False

        t_start = time.perf_counter()
        out = llm.create_chat_completion(
            messages=[{"role": "user", "content": prompt.format(text=txt)}],
            **params,
        )
        elapsed = time.perf_counter() - t_start
        result = (out["choices"][0]["message"]["content"] or "").strip()
        in_tokens = safe_token_count_messages(llm, [{"role": "user", "content": prompt.format(text=txt)}]) or 0
        out_tokens = safe_token_count_messages(llm, [{"role": "assistant", "content": result}]) or 0
        telemetry.update({
            "elapsedSec": round(elapsed, 4),
            "inputTokens": in_tokens,
            "outputTokens": out_tokens,
        })
    else:
        return txt, telemetry

    overlap_enabled = SETTINGS.get("query_sum_overlap_check_enabled")
    j_min = SETTINGS.get("query_sum_overlap_jaccard_min")
    if overlap_enabled is True and isinstance(j_min, (int, float)):
        src_toks = _tokens(txt)
        out_toks = _tokens(result)
        if not result or not out_toks:
            telemetry.update({"overlapRetained": True, "overlapScore": 0.0})
            return txt, telemetry
        jaccard = (len(src_toks & out_toks) / len(src_toks | out_toks)) if (src_toks or out_toks) else 1.0
        telemetry.update({"overlapScore": round(jaccard, 4)})
        if jaccard < float(j_min):
            telemetry.update({"overlapRetained": True})
            return txt, telemetry
        telemetry.update({"overlapRetained": False})
        return result, telemetry

    return result, telemetry

# ===== aimodel/file_read/web/router_ai.py =====

from __future__ import annotations
from typing import Tuple, Optional, Any, Dict
import json, re, time
from ..core.settings import SETTINGS
from ..utils.streaming import safe_token_count_messages
from ..utils.text import strip_wrappers as _strip_wrappers

def _force_json(s: str) -> dict:
    if not s:
        return {}
    raw = s.strip()
    try:
        cf = re.search(r"```(?:json)?\s*([\s\S]*?)\s*```", raw, re.IGNORECASE)
        if cf:
            raw = cf.group(1).strip()
    except Exception:
        pass
    try:
        v = json.loads(raw)
        return v if isinstance(v, dict) else {}
    except Exception:
        pass
    try:
        m = None
        for m in re.finditer(r"\{[^{}]*\"need\"\s*:\s*(?:true|false|\"true\"|\"false\")[^{}]*\}", raw, re.IGNORECASE):
            pass
        if m:
            frag = m.group(0)
            v = json.loads(frag)
            return v if isinstance(v, dict) else {}
    except Exception:
        pass
    try:
        last = None
        for last in re.finditer(r"\{[\s\S]*\}", raw):
            pass
        if last:
            frag = last.group(0)
            v = json.loads(frag)
            return v if isinstance(v, dict) else {}
    except Exception:
        pass
    return {}

def decide_web(llm: Any, user_text: str) -> Tuple[bool, Optional[str], Dict[str, Any]]:
    telemetry: Dict[str, Any] = {}
    try:
        if not user_text or not user_text.strip():
            return (False, None, telemetry)
        t_start = time.perf_counter()
        t_raw = user_text.strip()
        if SETTINGS.get("router_strip_wrappers_enabled") is True:
            core_text = _strip_wrappers(
                t_raw,
                trim_whitespace=SETTINGS.get("router_trim_whitespace") is True,
                split_on_blank=SETTINGS.get("router_strip_split_on_blank") is True,
                header_regex=SETTINGS.get("router_strip_header_regex"),
            )
        else:
            core_text = t_raw.strip() if SETTINGS.get("router_trim_whitespace") is True else t_raw
        prompt_tpl = SETTINGS.get("router_decide_prompt")
        if not isinstance(prompt_tpl, str) or not prompt_tpl.strip():
            return (False, None, telemetry)
        the_prompt = _safe_prompt_format(prompt_tpl, text=core_text)
        params = {
            "max_tokens": SETTINGS.get("router_decide_max_tokens"),
            "temperature": SETTINGS.get("router_decide_temperature"),
            "top_p": SETTINGS.get("router_decide_top_p"),
            "stream": False,
        }
        stop_list = SETTINGS.get("router_decide_stop")
        if isinstance(stop_list, list) and stop_list:
            params["stop"] = stop_list
        params = {k: v for k, v in params.items() if v is not None}
        raw_out_obj = llm.create_chat_completion(
            messages=[{"role": "user", "content": the_prompt}],
            **params,
        )
        text_out = (raw_out_obj.get("choices", [{}])[0]
                                  .get("message", {})
                                  .get("content") or "").strip()
        telemetry["rawRouterOut"] = text_out[:2000]
        data = _force_json(text_out) or {}
        need_val = data.get("need", None)
        if isinstance(need_val, str):
            nv = need_val.strip().lower()
            if nv in ("true", "yes", "y", "1"):
                need_val = True
            elif nv in ("false", "no", "n", "0"):
                need_val = False
        if isinstance(need_val, bool):
            need = need_val
            parsed_ok = True
        else:
            parsed_ok = False
            need_default = SETTINGS.get("router_default_need_when_invalid")
            need = bool(need_default) if isinstance(need_default, bool) else False
        query_field = data.get("query", "")
        try:
            if SETTINGS.get("router_strip_wrappers_enabled") is True:
                query = _strip_wrappers(
                    str(query_field or "").strip(),
                    trim_whitespace=SETTINGS.get("router_trim_whitespace") is True,
                    split_on_blank=SETTINGS.get("router_strip_split_on_blank") is True,
                    header_regex=SETTINGS.get("router_strip_header_regex"),
                )
            else:
                query = str(query_field or "").strip()
        except Exception:
            query = ""
        if not need:
            query = None
        t_elapsed = time.perf_counter() - t_start
        in_tokens = safe_token_count_messages(llm, [{"role": "user", "content": the_prompt}]) or 0
        out_tokens = safe_token_count_messages(llm, [{"role": "assistant", "content": text_out}]) or 0
        telemetry.update({
            "needed": bool(need),
            "routerQuery": query if need else None,
            "elapsedSec": round(t_elapsed, 4),
            "inputTokens": in_tokens,
            "outputTokens": out_tokens,
            "parsedOk": parsed_ok,
        })
        return (need, query, telemetry)
    except Exception:
        return (False, None, telemetry)

async def decide_web_and_fetch(llm: Any, user_text: str, *, k: int = 3) -> Tuple[Optional[str], Dict[str, Any]]:
    telemetry: Dict[str, Any] = {}
    need, proposed_q, tel_decide = decide_web(llm, (user_text or "").strip())
    telemetry.update(tel_decide)
    if not need:
        return None, telemetry
    from .query_summarizer import summarize_query
    from .orchestrator import build_web_block
    if SETTINGS.get("router_strip_wrappers_enabled") is True:
        base_query = _strip_wrappers(
            (proposed_q or user_text).strip(),
            trim_whitespace=SETTINGS.get("router_trim_whitespace") is True,
            split_on_blank=SETTINGS.get("router_strip_split_on_blank") is True,
            header_regex=SETTINGS.get("router_strip_header_regex"),
        )
    else:
        base_query = (proposed_q or user_text).strip()
    try:
        q_summary, tel_sum = summarize_query(llm, base_query)
        if SETTINGS.get("router_strip_wrappers_enabled") is True:
            q_summary = _strip_wrappers(
                (q_summary or "").strip(),
                trim_whitespace=SETTINGS.get("router_trim_whitespace") is True,
                split_on_blank=SETTINGS.get("router_strip_split_on_blank") is True,
                header_regex=SETTINGS.get("router_strip_header_regex"),
            ) or base_query
        else:
            q_summary = (q_summary or "").strip() or base_query
        telemetry["summarizer"] = tel_sum
        telemetry["summarizedQuery"] = q_summary
    except Exception:
        q_summary = base_query
    t_start = time.perf_counter()
    try:
        block_res = await build_web_block(q_summary, k=k)
        if isinstance(block_res, tuple):
            block, tel_orch = block_res
            telemetry["orchestrator"] = tel_orch or {}
        else:
            block = block_res
    except Exception:
        block = None
    t_elapsed = time.perf_counter() - t_start
    telemetry.update({
        "fetchElapsedSec": round(t_elapsed, 4),
        "blockChars": len(block) if block else 0,
    })
    return (block or None, telemetry)

def _safe_prompt_format(tpl: str, **kwargs) -> str:
    marker = "__ROUTER_TEXT_FIELD__"
    tmp = tpl.replace("{text}", marker)
    tmp = tmp.replace("{", "{{").replace("}", "}}")
    tmp = tmp.replace(marker, "{text}")
    return tmp.format(**kwargs)

# ===== aimodel/file_read/workers/retitle_worker.py =====

from __future__ import annotations
import asyncio, logging, re
from typing import Dict, List, Optional, Tuple
from ..runtime.model_runtime import get_llm
from ..store.index import load_index, save_index
from ..store.base import now_iso
from ..services.cancel import is_active, GEN_SEMAPHORE
from ..store.chats import _load_chat
from ..core.settings import SETTINGS

def S(key: str):
    return SETTINGS[key]

_PENDING: Dict[str, dict] = {}
_ENQUEUED: set[str] = set()
_queue: asyncio.Queue[str] = asyncio.Queue(maxsize=int(S("retitle_queue_maxsize")))
_lock = asyncio.Lock()

def _preview(s: str) -> str:
    n = int(S("retitle_preview_chars"))
    ell = S("retitle_preview_ellipsis")
    s = (s or "")
    return (s[:n] + ell) if len(s) > n else s

def _is_substantial(text: str) -> bool:
    t = (text or "").strip()
    min_chars = int(S("retitle_min_substantial_chars"))
    require_alpha = bool(S("retitle_require_alpha"))
    if len(t) < min_chars:
        return False
    return (re.search(r"[A-Za-z]", t) is not None) if require_alpha else True

def _pick_source(messages: List[dict]) -> Optional[str]:
    if not messages:
        return None
    min_user_len = int(S("retitle_min_user_chars"))
    for m in reversed(messages):
        if m.get("role") == "user":
            txt = (m.get("content") or "").strip()
            if len(txt) >= min_user_len and _is_substantial(txt):
                return txt
    for m in reversed(messages):
        if m.get("role") == "assistant":
            txt = (m.get("content") or "").strip()
            if _is_substantial(txt):
                return txt
    return None

def _sanitize_title(s: str) -> str:
    if not s:
        return ""
    s = s.strip()
    drop_prefix_re = S("retitle_sanitize_drop_prefix_regex")
    if drop_prefix_re:
        s = re.sub(drop_prefix_re, "", s)
    if bool(S("retitle_sanitize_strip_quotes")):
        s = s.strip().strip('"').strip("'").strip()
    replace_not_allowed_re = S("retitle_sanitize_replace_not_allowed_regex")
    replace_with = S("retitle_sanitize_replace_with")
    if replace_not_allowed_re:
        s = re.sub(replace_not_allowed_re, replace_with, s)
    s = re.sub(r"\s+", " ", s).strip()
    max_words = int(S("retitle_sanitize_max_words"))
    max_chars = int(S("retitle_sanitize_max_chars"))
    if max_words > 0:
        words = s.split()
        s = " ".join(words[:max_words])
    if max_chars > 0 and len(s) > max_chars:
        s = s[:max_chars].rstrip()
    return s

def _make_title(llm, src: str) -> str:
    hard = SETTINGS.get("retitle_llm_hard_prefix") or ""
    sys_extra = SETTINGS.get("retitle_llm_sys_inst") or ""
    sys = f"{hard}\n\n{sys_extra}".strip()
    user_text = f"{S('retitle_user_prefix')}{src}{S('retitle_user_suffix')}"
    messages = [
        {"role": "system", "content": sys},
        {"role": "user", "content": user_text},
    ]
    out = llm.create_chat_completion(
        messages=messages,
        max_tokens=int(S("retitle_llm_max_tokens")),
        temperature=float(S("retitle_llm_temperature")),
        top_p=float(S("retitle_llm_top_p")),
        stream=False,
        stop=S("retitle_llm_stop"),
    )
    raw = (out["choices"][0]["message"]["content"] or "").strip().strip('"').strip("'")
    strip_regex = SETTINGS.get("retitle_strip_regex")
    if strip_regex:
        raw = re.sub(strip_regex, "", raw).strip()
    raw = re.sub(r"^`{1,3}|`{1,3}$", "", raw).strip()
    raw = re.sub(r"[.:;,\-\s]+$", "", raw)
    return raw

async def start_worker():
    while True:
        sid = await _queue.get()
        try:
            await _process_session(sid)
        except Exception:
            logging.exception("Retitle worker failed")
        finally:
            _queue.task_done()

def _extract_job(snapshot: dict) -> Tuple[List[dict], int]:
    msgs = snapshot.get("messages") or []
    job_seq = int(snapshot.get("job_seq") or 0)
    return msgs, job_seq

async def _process_session(session_id: str):
    if not bool(S("retitle_enable")):
        return
    await asyncio.sleep(int(S("retitle_grace_ms")) / 1000.0)
    waited = 0
    backoff = int(S("retitle_active_backoff_start_ms"))
    backoff_max = int(S("retitle_active_backoff_max_ms"))
    backoff_total = int(S("retitle_active_backoff_total_ms"))
    growth = float(S("retitle_active_backoff_growth"))
    while is_active(session_id) and waited < backoff_total:
        await asyncio.sleep(backoff / 1000.0)
        waited += backoff
        backoff = min(int(backoff * growth), backoff_max)
    async with _lock:
        snapshot = _PENDING.pop(session_id, None)
        _ENQUEUED.discard(session_id)
    if not snapshot:
        return
    messages, job_seq = _extract_job(snapshot)
    try:
        cur_seq = int((_load_chat(session_id) or {}).get("seq") or 0)
    except Exception:
        cur_seq = job_seq
    if cur_seq > job_seq:
        return
    src = _pick_source(messages) or ""
    if not src.strip():
        return
    async with GEN_SEMAPHORE:
        llm = get_llm()
        try:
            title_raw = await asyncio.to_thread(_make_title, llm, src)
        except Exception as e:
            logging.exception("retitle: LLM error: %s", e)
            return
        finally:
            try:
                llm.reset()
            except Exception:
                pass
    title = _sanitize_title(title_raw) if bool(S("retitle_enable_sanitize")) else title_raw
    if not title:
        return
    idx = load_index()
    row = next((r for r in idx if r.get("sessionId") == session_id), None)
    if not row:
        return
    if (row.get("title") or "").strip() == title:
        return
    row["title"] = title
    row["updatedAt"] = now_iso()
    save_index(idx)

def enqueue(session_id: str, messages: List[dict], *, job_seq: Optional[int] = None):
    if not session_id:
        return
    if not isinstance(messages, list):
        messages = []
    if job_seq is None:
        try:
            job_seq = max(int(m.get("id") or 0) for m in messages) if messages else 0
        except Exception:
            job_seq = 0
    snap = {"messages": messages, "job_seq": int(job_seq)}
    async def _put():
        async with _lock:
            _PENDING[session_id] = snap
            if session_id not in _ENQUEUED:
                _ENQUEUED.add(session_id)
                try:
                    _queue.put_nowait(session_id)
                except Exception as e:
                    logging.warning(f"Failed to enqueue retitle: {e}")
    try:
        loop = asyncio.get_running_loop()
        loop.create_task(_put())
    except RuntimeError:
        asyncio.run(_put())

# ===== frontend/src/file_read/App.tsx =====

import AgentRunner from "./pages/AgentRunner";
import { useAuth } from "./auth/AuthContext";
import SignIn from "./auth/SignIn";
import SignUp from "./auth/SignUp";
import ForgotPassword from "./auth/ForgotPassword";
import { useState } from "react";

export default function App() {
  const { user, loading } = useAuth();
  const [mode, setMode] = useState<"signin" | "signup" | "forgot">("signin");

  // BYPASS: render app even if not signed in
  if (import.meta.env.VITE_BYPASS_AUTH === "true") {
    return (
      <main className="bg-gray-50 h-screen overflow-hidden">
        <AgentRunner />
      </main>
    );
  }

  if (loading) {
    return <main className="min-h-screen grid place-items-center">Loading…</main>;
  }

  if (!user) {
    return (
      <main className="min-h-screen grid place-items-center bg-gray-50 px-4">
        <div className="w-full max-w-sm bg-white p-6 rounded-2xl shadow">
          {mode === "signin" && <SignIn />}
          {mode === "signup" && <SignUp />}
          {mode === "forgot" && <ForgotPassword />}

          <div className="mt-4 text-sm text-center text-gray-700">
            {mode !== "signin" && (
              <button onClick={() => setMode("signin")} className="underline mx-2">Sign in</button>
            )}
            {mode !== "signup" && (
              <button onClick={() => setMode("signup")} className="underline mx-2">Create account</button>
            )}
            {mode !== "forgot" && (
              <button onClick={() => setMode("forgot")} className="underline mx-2">Forgot password</button>
            )}
          </div>
        </div>
      </main>
    );
  }

  return (
    <main className="bg-gray-50 h-screen overflow-hidden">
      <AgentRunner />
    </main>
  );
}

# ===== frontend/src/file_read/auth/AuthContext.tsx =====

// frontend/src/file_read/auth/AuthContext.tsx
import React, { createContext, useContext, useEffect, useMemo, useState } from "react";
import { getJSON } from "../services/http";

type LocalUser = {
  email?: string;
  name?: string;
  // add more fields if your /auth/me returns them
};

type Ctx = {
  user: LocalUser | null;
  loading: boolean;
  setToken: (t: string | null) => void;
  logout: () => void;
};

const AuthContext = createContext<Ctx>({
  user: null,
  loading: true,
  setToken: () => {},
  logout: () => {},
});

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [token, _setToken] = useState<string | null>(null);
  const [user, setUser] = useState<LocalUser | null>(null);
  const [loading, setLoading] = useState(true);

  // Single writer for token + localStorage
  const setToken = (t: string | null) => {
    _setToken(t);
    try {
      if (t) localStorage.setItem("local_jwt", t);
      else localStorage.removeItem("local_jwt");
    } catch {}
  };

  const logout = () => {
    setToken(null);
    setUser(null);
  };

  // On mount: read token and load profile (if any)
  useEffect(() => {
    let cancelled = false;
    (async () => {
      try {
        const t = localStorage.getItem("local_jwt");
        if (t) {
          _setToken(t);
          // Optional profile fetch; your backend should accept Authorization: Bearer <jwt>
          try {
            const me = await getJSON<LocalUser>("/auth/me");
            if (!cancelled) setUser(me || null);
            // store for UI label fallback (avatar initials)
            if (me?.email) localStorage.setItem("profile_email", me.email);
          } catch {
            // if /auth/me not implemented, fall back to localStorage email
            const stored = localStorage.getItem("profile_email") || "";
            if (!cancelled) setUser(stored ? { email: stored } : { email: undefined });
          }
        } else {
          // no token: not logged in
          if (!cancelled) {
            setUser(null);
          }
        }
      } finally {
        if (!cancelled) setLoading(false);
      }
    })();
    return () => {
      cancelled = true;
    };
  }, []);

  // If token changes later (SignIn/SignUp), refresh /auth/me
  useEffect(() => {
    let cancelled = false;
    (async () => {
      if (!token) return;
      try {
        const me = await getJSON<LocalUser>("/auth/me");
        if (!cancelled) setUser(me || null);
        if (me?.email) localStorage.setItem("profile_email", me.email);
      } catch {
        // okay to ignore if not implemented
        const stored = localStorage.getItem("profile_email") || "";
        if (!cancelled) setUser(stored ? { email: stored } : { email: undefined });
      }
    })();
    return () => {
      cancelled = true;
    };
  }, [token]);

  const ctx = useMemo<Ctx>(() => ({ user, loading, setToken, logout }), [user, loading]);

  return <AuthContext.Provider value={ctx}>{children}</AuthContext.Provider>;
};

export const useAuth = () => useContext(AuthContext);

# ===== frontend/src/file_read/auth/ForgotPassword.tsx =====

// frontend/src/file_read/auth/ForgotPassword.tsx
import { useState } from "react";
import { postJSON } from "../services/http";

export default function ForgotPassword() {
  const [email, setEmail] = useState("");
  const [sent, setSent] = useState(false);
  const [err, setErr] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);
    setSent(false);
    setSubmitting(true);
    try {
      // Backend should implement: POST /auth/forgot  { email }
      // Behavior suggestion:
      //  - If SMTP configured: send email with reset link/token
      //  - If offline: generate token and print reset URL to server logs (admin shares it)
      await postJSON("/auth/forgot", { email: email.trim().toLowerCase() });
      setSent(true);
    } catch (e: any) {
      // Common cases: 404 if endpoint not implemented, or 400/422 for bad email
      const msg = (e?.message as string) || "";
      if (/HTTP 404/i.test(msg)) {
        setErr("Password reset isn’t enabled on this box. Ask the admin to reset your password.");
      } else {
        setErr(msg.replace(/^HTTP \d+\s*–\s*/, "") || "Could not send reset request");
      }
    } finally {
      setSubmitting(false);
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-4">
      <h1 className="text-xl font-semibold text-center">Reset password</h1>

      <div className="space-y-1">
        <label className="block text-sm text-gray-700">Email</label>
        <input
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          type="email"
          inputMode="email"
          autoComplete="email"
          required
          className="w-full rounded-lg border border-gray-300 px-3 py-2 outline-none focus:ring-2 focus:ring-black"
          placeholder="you@example.com"
        />
      </div>

      {sent && (
        <div className="text-sm text-green-700 bg-green-50 border border-green-200 rounded-lg px-3 py-2">
          If password reset is enabled, a link has been sent (or printed in the server logs if email isn’t configured).
          Contact your admin if you don’t receive it.
        </div>
      )}

      {err && (
        <div className="text-sm text-red-600 bg-red-50 border border-red-200 rounded-lg px-3 py-2">
          {err}
        </div>
      )}

      <button
        type="submit"
        disabled={submitting}
        className="w-full rounded-lg bg-black text-white py-2.5 font-medium disabled:opacity-60"
      >
        {submitting ? "Sending…" : "Send reset request"}
      </button>
    </form>
  );
}

# ===== frontend/src/file_read/auth/localAuth.ts =====

import { buildUrl } from "../services/http";

const KEY = "local_jwt";
export function getLocalToken(): string | null { return localStorage.getItem(KEY); }
export function setLocalToken(tok: string | null) { tok ? localStorage.setItem(KEY, tok) : localStorage.removeItem(KEY); }

export async function localRegister(email: string, password: string) {
  const r = await fetch(buildUrl("/auth/register"), {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  if (!r.ok) throw new Error(await r.text());
}

export async function localLogin(email: string, password: string) {
  const r = await fetch(buildUrl("/auth/login"), {
    method: "POST", headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  if (!r.ok) throw new Error(await r.text());
  const data = await r.json();
  setLocalToken(data.access_token);
}

export function localLogout() { setLocalToken(null); }

# ===== frontend/src/file_read/auth/SignIn.tsx =====

import { useState } from "react";
import { localLogin, localRegister } from "./localAuth";
import { useAuth } from "./AuthContext";

export default function SignIn() {
  const { setToken } = useAuth();
  const [email, setEmail] = useState("");
  const [pw, setPw] = useState("");
  const [err, setErr] = useState<string | null>(null);
  const [mode, setMode] = useState<"signin" | "signup">("signin");
  const [busy, setBusy] = useState(false);

  async function submit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null); setBusy(true);
    try {
      if (mode === "signup") {
        await localRegister(email, pw);
      }
      await localLogin(email, pw);
      // token is stored by localLogin; poke context to re-evaluate
      setToken(localStorage.getItem("local_jwt"));
    } catch (e: any) {
      setErr(e?.message || "Auth failed");
    } finally { setBusy(false); }
  }

  return (
    <form onSubmit={submit} className="space-y-3">
      <h1 className="text-lg font-semibold">{mode === "signin" ? "Sign in" : "Create account"}</h1>
      <input className="w-full border rounded px-3 py-2" placeholder="Email" value={email} onChange={e=>setEmail(e.target.value)} />
      <input className="w-full border rounded px-3 py-2" placeholder="Password" type="password" value={pw} onChange={e=>setPw(e.target.value)} />
      {err && <div className="text-sm text-red-600">{err}</div>}
      <button disabled={busy} className="w-full rounded bg-black text-white py-2">{busy ? "Please wait…" : (mode === "signin" ? "Sign in" : "Sign up")}</button>
      <div className="text-sm text-center">
        {mode === "signin" ? (
          <button type="button" className="underline" onClick={()=>setMode("signup")}>Create account</button>
        ) : (
          <button type="button" className="underline" onClick={()=>setMode("signin")}>Have an account? Sign in</button>
        )}
      </div>
    </form>
  );
}

# ===== frontend/src/file_read/auth/SignUp.tsx =====

// frontend/src/file_read/auth/SignUp.tsx
import { useState } from "react";
import { Eye, EyeOff } from "lucide-react";
import { localRegister, localLogin } from "./localAuth";
import { useAuth } from "./AuthContext";

export default function SignUp() {
  const { setToken } = useAuth();
  const [email, setEmail] = useState("");
  const [pw, setPw] = useState("");
  const [confirmPw, setConfirmPw] = useState("");
  const [err, setErr] = useState<string | null>(null);
  const [submitting, setSubmitting] = useState(false);
  const [showPw, setShowPw] = useState(false);
  const [showConfirm, setShowConfirm] = useState(false);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    setErr(null);

    const em = email.trim().toLowerCase();
    if (!em) return setErr("Email is required");
    if (pw.length < 6) return setErr("Password must be at least 6 characters");
    if (pw !== confirmPw) return setErr("Passwords do not match");

    setSubmitting(true);
    try {
      await localRegister(em, pw);     // create user locally
      await localLogin(em, pw);        // get JWT + store in localStorage
      setToken(localStorage.getItem("local_jwt")); // notify context (logged in)
    } catch (e: any) {
      setErr(e?.message || "Sign up failed");
      setSubmitting(false);
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-4">
      <h1 className="text-xl font-semibold text-center">Create account</h1>

      <div className="space-y-1">
        <label className="block text-sm text-gray-700">Email</label>
        <input
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          type="email"
          inputMode="email"
          autoComplete="email"
          required
          className="w-full rounded-lg border border-gray-300 px-3 py-2 outline-none focus:ring-2 focus:ring-black"
          placeholder="you@example.com"
        />
      </div>

      <div className="space-y-1">
        <label className="block text-sm text-gray-700">Password</label>
        <div className="relative">
          <input
            value={pw}
            onChange={(e) => setPw(e.target.value)}
            type={showPw ? "text" : "password"}
            autoComplete="new-password"
            minLength={6}
            required
            className="w-full rounded-lg border border-gray-300 px-3 py-2 pr-10 outline-none focus:ring-2 focus:ring-black"
            placeholder="At least 6 characters"
          />
          <button
            type="button"
            onClick={() => setShowPw((s) => !s)}
            className="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500"
            aria-label={showPw ? "Hide password" : "Show password"}
          >
            {showPw ? <EyeOff size={18} /> : <Eye size={18} />}
          </button>
        </div>
      </div>

      <div className="space-y-1">
        <label className="block text-sm text-gray-700">Confirm Password</label>
        <div className="relative">
          <input
            value={confirmPw}
            onChange={(e) => setConfirmPw(e.target.value)}
            type={showConfirm ? "text" : "password"}
            autoComplete="new-password"
            minLength={6}
            required
            className="w-full rounded-lg border border-gray-300 px-3 py-2 pr-10 outline-none focus:ring-2 focus:ring-black"
            placeholder="Re-enter password"
          />
          <button
            type="button"
            onClick={() => setShowConfirm((s) => !s)}
            className="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-500"
            aria-label={showConfirm ? "Hide confirm password" : "Show confirm password"}
          >
            {showConfirm ? <EyeOff size={18} /> : <Eye size={18} />}
          </button>
        </div>
      </div>

      {err && (
        <div className="text-sm text-red-600 bg-red-50 border border-red-200 rounded-lg px-3 py-2">
          {err}
        </div>
      )}

      <button
        type="submit"
        disabled={submitting}
        className="w-full rounded-lg bg-black text-white py-2.5 font-medium disabled:opacity-60"
      >
        {submitting ? "Creating…" : "Create account"}
      </button>
    </form>
  );
}

# ===== frontend/src/file_read/components/AssistantMetrics.tsx =====

// frontend/src/file_read/components/chat/AssistantMetrics.tsx
import { Info } from "lucide-react";
import MetricsHoverCard from "./MetricsHoverCard";
import type { RunJson, GenMetrics } from "../shared/lib/runjson";

export default function AssistantMetrics({
  status,
  runJson,
  flat,
  align = "right",
}: { status: string; runJson?: RunJson | null; flat?: GenMetrics | null; align?: "left" | "right" }) {
  return (
    <div className="mt-2 flex justify-start">
      <div className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-white border shadow-sm text-[11px] text-gray-600">
        <Info className="w-3.5 h-3.5 opacity-70" />
        <span className="truncate max-w-[70vw] sm:max-w-none">{status || "Run details"}</span>
        <MetricsHoverCard
          data={
            runJson ??
            (flat
              ? {
                  stats: {
                    stopReason: flat.stop_reason ?? null,
                    tokensPerSecond: flat.tok_per_sec ?? null,
                    timeToFirstTokenSec: flat.ttft_ms != null ? Math.max(0, flat.ttft_ms) / 1000 : null,
                    totalTimeSec: null,
                    promptTokensCount: flat.input_tokens_est ?? null,
                    predictedTokensCount: flat.output_tokens ?? null,
                    totalTokensCount: flat.total_tokens_est ?? null,
                  },
                }
              : null)
          }
          title="Run JSON"
          align={align}
          compact
        />
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/Budget/BudgetBar.tsx =====

// frontend/src/file_read/components/Budget/BudgetBar.tsx

import { useState } from "react";
import {
  type RunJson,
  getNormalizedBudget,
  getRagTelemetry,
  getWebTelemetry,
  getTimingMetrics,
  getPackTelemetry,
  getThroughput,
} from "../../shared/lib/runjson";
import {
  RagPanel,
  WebPanel,
  TimingPanel,
} from "./BudgetBarPanelsExtras";
import {
  num,
  PackPanel,
} from "./BudgetBarPanelsCore";

import { ChevronDown, ChevronUp } from "lucide-react";

function pct(n: number, d: number) {
  if (!Number.isFinite(n) || !Number.isFinite(d) || d <= 0) return 0;
  return Math.max(0, Math.min(100, (n / d) * 100));
}

export default function BudgetBar({ runJson }: { runJson?: RunJson | null }) {
  const nb = getNormalizedBudget(runJson ?? undefined);
  if (!nb) return null;

  const [open, setOpen] = useState(false);

  const rag = getRagTelemetry(runJson ?? undefined) as any | null;
  const web = getWebTelemetry(runJson ?? undefined) as any | null;
  const pack = getPackTelemetry(runJson ?? undefined) as any | null;
  const timing = getTimingMetrics(runJson ?? undefined) as any | null;
  const tps = getThroughput(runJson ?? undefined);

  const breakdown =
    (runJson as any)?.budget_view?.breakdown ??
    (runJson as any)?.stats?.budget?.breakdown ??
    null;

  const modelCtx = num(nb.modelCtx);
  const clampMargin = num(nb.clampMargin);
  const inputTokensEst = num(nb.inputTokensEst);
  const outBudgetChosen = num(nb.outBudgetChosen);
  const outActual = num(runJson?.stats?.predictedTokensCount);
  const outShown = outActual || outBudgetChosen;

  const used = inputTokensEst + outShown + clampMargin;
  const fullPct = pct(used, modelCtx);

  const ragDelta = Math.max(
    0,
    num(rag?.ragTokensAdded) ||
      num(rag?.blockTokens) ||
      num(rag?.blockTokensApprox) ||
      num(rag?.sessionOnlyTokensApprox)
  );
  const ragWasInjected = !!(rag?.injected || rag?.sessionOnly || ragDelta > 0);
  const ragPctOfInput = inputTokensEst > 0 ? Math.round((ragDelta / inputTokensEst) * 100) : 0;
  const ragBlockBuildTime =
    rag?.injectBuildSec ?? rag?.blockBuildSec ?? rag?.sessionOnlyBuildSec;

  const webRouteSec = web?.elapsedSec;
  const webFetchSec = web?.fetchElapsedSec;
  const webInjectSec = web?.injectElapsedSec;
  const webPre =
    num((web as any)?.breakdown?.totalWebPreTtftSec) ||
    (num(webRouteSec) + num(webFetchSec) + num(webInjectSec));

  const packPackSec = num(pack?.packSec);
  const packSummarySec = num(pack?.summarySec);
  const packFinalTrimSec = num(pack?.finalTrimSec);
  const packCompressSec = num(pack?.compressSec);
  const packSummaryTokens = num(pack?.summaryTokensApprox);
  const packSummaryUsedLLM = !!pack?.summaryUsedLLM;

  const droppedMsgs = num((pack as any)?.finalTrimDroppedMsgs);
  const droppedApproxTok = num((pack as any)?.finalTrimDroppedApproxTokens);
  const sumShrinkFrom = num((pack as any)?.finalTrimSummaryShrunkFromChars);
  const sumShrinkTo = num((pack as any)?.finalTrimSummaryShrunkToChars);
  const sumShrinkDropped = num((pack as any)?.finalTrimSummaryDroppedChars);
  const rolledPeeledMsgs = num((pack as any)?.rollPeeledMsgs);
  const rollNewSummaryTokens = num((pack as any)?.rollNewSummaryTokensApprox);

  const engine = timing?.engine || null;
  const engineLoadSec = num(engine?.loadSec);
  const enginePromptSec = num(engine?.promptSec);
  const engineEvalSec = num(engine?.evalSec);
  const enginePromptN = engine?.promptN;
  const engineEvalN = engine?.evalN;

  const preModelSec = num(timing?.preModelSec);
  const modelQueueSec = num(timing?.modelQueueSec);

  const preAccountedFromBackend = num(breakdown?.preTtftAccountedSec);
  const accountedFallback =
    webPre +
    num(rag?.routerDecideSec) +
    num(ragBlockBuildTime) +
    packPackSec +
    packSummarySec +
    packFinalTrimSec +
    packCompressSec +
    preModelSec +
    modelQueueSec;
  const accounted = preAccountedFromBackend || accountedFallback;

  const unattributed =
    (breakdown && Number.isFinite(breakdown.unattributedTtftSec))
      ? num(breakdown.unattributedTtftSec)
      : Math.max(0, num(timing?.ttftSec) - accounted);

  return (
    <div className="px-3 py-2 border-t bg-white/90 backdrop-blur sticky bottom-0 z-40">
      <div className="flex items-center gap-2 text-[11px] text-gray-700">
        <button
          type="button"
          onClick={() => setOpen((v) => !v)}
          aria-expanded={open ? "true" : "false"}
          className="shrink-0 inline-flex items-center gap-1 px-2 h-6 rounded border bg-white hover:bg-gray-50"
          title={open ? "Hide details" : "Show details"}
        >
          {open ? <ChevronDown className="w-3.5 h-3.5" /> : <ChevronUp className="w-3.5 h-3.5" />}
          <span className="hidden sm:inline">Details</span>
        </button>

        <div
          className="flex-1 h-1.5 rounded bg-gray-200 overflow-hidden"
          title={`Context ${fullPct.toFixed(1)}%`}
        >
          <div className="h-1.5 bg-black" style={{ width: `${fullPct}%` }} />
        </div>

        <div className="whitespace-nowrap hidden xs:block">
          In: <span className="font-medium">{inputTokensEst}</span>
        </div>
        <div className="whitespace-nowrap hidden xs:block">
          Out: <span className="font-medium">{outShown}</span>
        </div>
        <div className="whitespace-nowrap hidden sm:block">
          Ctx: <span className="font-medium">{modelCtx}</span>
        </div>
        <div className="whitespace-nowrap text-gray-500 hidden md:block">
          {`Context is ${fullPct.toFixed(1)}% full`}
        </div>
      </div>

      {open && (
        <div className="mt-2 max-h-40 sm:max-h-48 md:max-h-56 overflow-y-auto pr-1 pb-1 -mr-1">
          {pack && (
            <PackPanel
              pack={pack}
              packPackSec={packPackSec}
              packSummarySec={packSummarySec}
              packFinalTrimSec={packFinalTrimSec}
              packCompressSec={packCompressSec}
              packSummaryTokens={packSummaryTokens}
              packSummaryUsedLLM={packSummaryUsedLLM}
              droppedMsgs={droppedMsgs}
              droppedApproxTok={droppedApproxTok}
              sumShrinkFrom={sumShrinkFrom}
              sumShrinkTo={sumShrinkTo}
              sumShrinkDropped={sumShrinkDropped}
              rolledPeeledMsgs={rolledPeeledMsgs}
              rollNewSummaryTokens={rollNewSummaryTokens}
            />
          )}

          {rag && (
            <RagPanel
              rag={rag}
              ragWasInjected={ragWasInjected}
              ragBlockBuildTime={ragBlockBuildTime}
              ragDelta={ragDelta}
              ragPctOfInput={ragPctOfInput}
              inputTokensEst={inputTokensEst}
            />
          )}

          {web && <WebPanel web={web} />}

          {timing && (
            <TimingPanel
              timing={timing}
              enginePromptSec={enginePromptSec}
              engineEvalSec={engineEvalSec}
              engineLoadSec={engineLoadSec}
              enginePromptN={enginePromptN}
              engineEvalN={engineEvalN}
              preModelSec={preModelSec}
              modelQueueSec={modelQueueSec}
              unattributed={unattributed}
              encodeTps={tps?.encodeTps ?? null}
              decodeTps={tps?.decodeTps ?? null}
              overallTps={tps?.overallTps ?? null}
            />
          )}
        </div>
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/Budget/BudgetBarPanelsCore.tsx =====

// frontend/src/file_read/components/Budget/BudgetBarPanelsCore.tsx
export const num = (v: unknown) =>
  typeof v === "number" && Number.isFinite(v) ? v : 0;

export function fmtSec(v?: number) {
  if (v == null || !Number.isFinite(v)) return "—";
  if (v < 0.01) return "<0.01s";
  return `${v.toFixed(2)}s`;
}

export function fmtTps(v?: number | null) {
  if (v == null || !Number.isFinite(v)) return "—";
  if (v < 1) return v.toFixed(2);
  if (v < 10) return v.toFixed(1);
  return Math.round(v).toString();
}

type PackPanelProps = {
  pack: any;
  packPackSec: number;
  packSummarySec: number;
  packFinalTrimSec: number;
  packCompressSec: number;
  packSummaryTokens: number;
  packSummaryUsedLLM: boolean;
  droppedMsgs: number;
  droppedApproxTok: number;
  sumShrinkFrom: number;
  sumShrinkTo: number;
  sumShrinkDropped: number;
  rolledPeeledMsgs: number;
  rollNewSummaryTokens: number;
};

export function PackPanel({
  pack,
  packPackSec,
  packSummarySec,
  packFinalTrimSec,
  packCompressSec,
  packSummaryTokens,
  packSummaryUsedLLM,
  droppedMsgs,
  droppedApproxTok,
  sumShrinkFrom,
  sumShrinkTo,
  sumShrinkDropped,
  rolledPeeledMsgs,
  rollNewSummaryTokens,
}: PackPanelProps) {
  return (
    <div className="mt-2 text-[11px] text-gray-700">
      <div className="flex flex-wrap items-center gap-x-4 gap-y-1">
        {"packSec" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            pack {fmtSec(packPackSec)}
          </span>
        )}
        {"summarySec" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            summary {fmtSec(packSummarySec)} {packSummaryUsedLLM ? "(llm)" : "(fast)"}
          </span>
        )}
        {"finalTrimSec" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            trim {fmtSec(packFinalTrimSec)}
          </span>
        )}
        {"compressSec" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            compress {fmtSec(packCompressSec)}
          </span>
        )}
        {"summaryTokensApprox" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            sumTokens≈<b>{packSummaryTokens}</b>
          </span>
        )}
        {"packedChars" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            packed chars=<b>{(pack as any).packedChars}</b>
          </span>
        )}
        {"messages" in pack && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            msgs=<b>{(pack as any).messages}</b>
          </span>
        )}

        {(droppedMsgs > 0 || droppedApproxTok > 0) && (
          <span className="px-1.5 py-0.5 rounded bg-red-50 border border-red-200 text-red-700">
            dropped msgs=<b>{droppedMsgs}</b>
            {droppedApproxTok ? (
              <>
                {" "}
                / ≈<b>{droppedApproxTok}</b> tok
              </>
            ) : null}
          </span>
        )}

        {sumShrinkDropped > 0 && (
          <span className="px-1.5 py-0.5 rounded bg-amber-50 border border-amber-200 text-amber-800">
            summary shrink {sumShrinkFrom}→{sumShrinkTo} chars (−<b>{sumShrinkDropped}</b>)
          </span>
        )}

        {rolledPeeledMsgs > 0 && (
          <span className="px-1.5 py-0.5 rounded bg-blue-50 border border-blue-200 text-blue-800">
            rolled: <b>{rolledPeeledMsgs}</b> msgs → +sum≈<b>{rollNewSummaryTokens}</b> tok
          </span>
        )}
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/Budget/BudgetBarPanelsExtras.tsx =====

// frontend/src/file_read/components/Budget/BudgetBarPanelsExtras.tsx
import { fmtSec, fmtTps } from "./BudgetBarPanelsCore";

type RagPanelProps = {
  rag: any;
  ragWasInjected: boolean;
  ragBlockBuildTime?: number;
  ragDelta: number;
  ragPctOfInput: number;
  inputTokensEst: number;
};

export function RagPanel({
  rag,
  ragWasInjected,
  ragBlockBuildTime,
  ragDelta,
  ragPctOfInput,
  inputTokensEst,
}: RagPanelProps) {
  const routerNeeded = rag?.routerNeeded;
  const routerSkipped = rag?.routerSkipped;
  const routerSkippedReason = rag?.routerSkippedReason;
  const routerDecideSec = rag?.routerDecideSec;
  const embedSec = rag?.embedSec;
  const searchChatSec = rag?.searchChatSec;
  const searchGlobalSec = rag?.searchGlobalSec;
  const dedupeSec = rag?.dedupeSec;
  const topKRequested = rag?.topKRequested;
  const hitsChat = rag?.hitsChat;
  const hitsGlobal = rag?.hitsGlobal;
  const blockChars = rag?.blockChars ?? rag?.sessionOnlyChars;
  const routerQuery = rag?.routerQuery;

  return (
    <div className="mt-2 text-[11px] text-gray-700">
      <div className="flex flex-wrap items-center gap-x-4 gap-y-1">
        <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
          RAG: <b>{ragWasInjected ? "injected" : "skipped"}</b> {rag?.mode ? `(${rag.mode})` : rag?.sessionOnly ? "(session-only)" : ""}
        </span>
        {"routerNeeded" in rag && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            router: <b>{routerNeeded ? "yes" : "no"}</b>
          </span>
        )}
        {routerSkipped && (
          <span className="px-1.5 py-0.5 rounded bg-amber-50 border border-amber-200 text-amber-800">
            skipped {routerSkippedReason ? `(${routerSkippedReason})` : ""}
          </span>
        )}
        {"routerDecideSec" in rag && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            route {fmtSec(routerDecideSec)}
          </span>
        )}
        {"embedSec" in rag && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            embed {fmtSec(embedSec)}
          </span>
        )}
        {("searchChatSec" in rag || "searchGlobalSec" in rag) && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            search {fmtSec(searchChatSec)} / {fmtSec(searchGlobalSec)}
          </span>
        )}
        {"dedupeSec" in rag && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            dedupe {fmtSec(dedupeSec)}
          </span>
        )}
        {ragBlockBuildTime !== undefined && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            block {fmtSec(ragBlockBuildTime)}
          </span>
        )}
        {topKRequested != null && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">k=<b>{topKRequested}</b></span>
        )}
        {hitsChat != null && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">hits chat=<b>{hitsChat}</b></span>
        )}
        {hitsGlobal != null && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">global=<b>{hitsGlobal}</b></span>
        )}
        {(rag.ragTokensAdded != null || rag.blockTokens != null || rag.blockTokensApprox != null || rag.sessionOnlyTokensApprox != null) && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            +RAG tokens=<b>{ragDelta}</b>
            {inputTokensEst ? ` (${ragPctOfInput}% of input)` : ""}
          </span>
        )}
        {blockChars != null && (
          <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
            block chars=<b>{blockChars}</b>
          </span>
        )}
      </div>
      {routerQuery && (
        <div className="mt-1 text-[10px] text-gray-500 truncate" title={routerQuery}>
          query: {routerQuery}
        </div>
      )}
    </div>
  );
}

type WebPanelProps = {
  web: any;
};

export function WebPanel({ web }: WebPanelProps) {
  const webWasInjected = !!web?.injected;
  const webNeeded = web?.needed;
  const webRouteSec = web?.elapsedSec;
  const webFetchSec = web?.fetchElapsedSec;
  const webInjectSec = web?.injectElapsedSec;
  const webBlockChars = web?.blockChars;
  const webEphemeralBlocks = web?.ephemeralBlocks;
  const summarizedQuery = web?.summarizedQuery;

  return (
    <div className="mt-2 text-[11px] text-gray-700">
      <div className="flex flex-wrap items-center gap-x-4 gap-y-1">
        <span className="px-1.5 py-0.5 rounded bg-gray-100 border">
          WEB: <b>{webWasInjected ? "injected" : "skipped"}</b>
          {webNeeded !== undefined ? <> (router: <b>{webNeeded ? "need" : "no"}</b>)</> : null}
        </span>
        {"elapsedSec" in web && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">route {fmtSec(webRouteSec)}</span>}
        {"fetchElapsedSec" in web && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">fetch {fmtSec(webFetchSec)}</span>}
        {"injectElapsedSec" in web && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">inject {fmtSec(webInjectSec)}</span>}
        {"blockChars" in web && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">block chars=<b>{webBlockChars}</b></span>}
        {"ephemeralBlocks" in web && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">eph blocks=<b>{webEphemeralBlocks}</b></span>}
        {web.droppedFromSummary && (
  <span className="px-1.5 py-0.5 rounded bg-purple-50 border border-purple-200 text-purple-800">
    dropped after turn
  </span>
)}
      </div>
      {summarizedQuery && (
        <div className="mt-1 text-[10px] text-gray-500 truncate" title={summarizedQuery}>
          query: {summarizedQuery}
        </div>
      )}
    </div>
  );
}

type TimingPanelProps = {
  timing: any;
  enginePromptSec?: number;
  engineEvalSec?: number;
  engineLoadSec?: number;
  enginePromptN?: number | null;
  engineEvalN?: number | null;
  preModelSec?: number;
  modelQueueSec?: number;
  unattributed?: number;
  encodeTps?: number | null;
  decodeTps?: number | null;
  overallTps?: number | null;
};

export function TimingPanel({
  timing,
  enginePromptSec,
  engineEvalSec,
  engineLoadSec,
  enginePromptN,
  engineEvalN,
  preModelSec,
  modelQueueSec,
  unattributed,
  encodeTps,
  decodeTps,
  overallTps,
}: TimingPanelProps) {
  return (
    <div className="mt-2 text-[11px] text-gray-700">
      <div className="flex flex-wrap items-center gap-x-4 gap-y-1">
        <span className="px-1.5 py-0.5 rounded bg-gray-100 border">ttft {fmtSec(timing.ttftSec ?? undefined)}</span>
        {"queueWaitSec" in timing && timing.queueWaitSec != null && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">queue {fmtSec(timing.queueWaitSec)}</span>}
        {"genSec" in timing && timing.genSec != null && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">gen {fmtSec(timing.genSec)}</span>}
        {"totalSec" in timing && timing.totalSec != null && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">total {fmtSec(timing.totalSec)}</span>}
        {!!enginePromptSec && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">prefill {fmtSec(enginePromptSec)}</span>}
        {!!engineEvalSec && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">eval {fmtSec(engineEvalSec)}</span>}
        {!!engineLoadSec && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">load {fmtSec(engineLoadSec)}</span>}
        {enginePromptN != null && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">promptN={enginePromptN}</span>}
        {engineEvalN != null && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">evalN={engineEvalN}</span>}
        {!!preModelSec && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">pre-model {fmtSec(preModelSec)}</span>}
        {!!modelQueueSec && <span className="px-1.5 py-0.5 rounded bg-gray-100 border">model-queue {fmtSec(modelQueueSec)}</span>}
        <span className="px-1.5 py-0.5 rounded bg-gray-100 border">unattributed {fmtSec(unattributed)}</span>
        {encodeTps != null && <span className="px-1.5 py-0.5 rounded bg-green-50 border border-green-200 text-green-800">encode <b>{fmtTps(encodeTps)}</b> tok/s</span>}
        {decodeTps != null && <span className="px-1.5 py-0.5 rounded bg-indigo-50 border border-indigo-200 text-indigo-800">decode <b>{fmtTps(decodeTps)}</b> tok/s</span>}
        {overallTps != null && <span className="px-1.5 py-0.5 rounded bg-gray-50 border">overall <b>{fmtTps(overallTps)}</b> tok/s</span>}
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatBubble.tsx =====

import { useState } from "react";
import { Copy, Check, Trash2 } from "lucide-react";
import MarkdownMessage from "./Markdown/MarkdownMessage";
import { stripRunJson } from "../shared/lib/runjson";
import type { Attachment } from "../types/chat";   // ✅ import Attachment type

const STOP_SENTINEL_RE = /(?:\r?\n)?(?:\u23F9|\\u23F9)\s+stopped(?:\r?\n)?$/u;

export default function ChatBubble({
  role,
  text,
  attachments = [],   // ✅ new prop
  showActions = true,
  onDelete,
}: {
  role: "user" | "assistant";
  text: string;
  attachments?: Attachment[];   // ✅ allow attachments
  showActions?: boolean;
  onDelete?: () => void;
}) {
  const isUser = role === "user";
  const raw = text ?? "";
  const { text: stripped } = stripRunJson(raw);
  let content = stripped.trim();

  if (!isUser) content = content.replace(STOP_SENTINEL_RE, "");

  const hasOnlyAttachments =
    isUser && (!content || content.length === 0) && attachments.length > 0;

  if (role === "assistant" && !content && attachments.length === 0) return null;

  const [copiedMsg, setCopiedMsg] = useState(false);
  const copyWholeMessage = async () => {
    try {
      await navigator.clipboard.writeText(content);
      setCopiedMsg(true);
      setTimeout(() => setCopiedMsg(false), 2000);
    } catch {}
  };

  return (
    <div className="mb-2">
      <div className={`flex ${isUser ? "justify-end" : "justify-start"}`}>
        <div
          className={`max-w-[80%] w-fit break-words rounded-2xl px-4 py-2 shadow-sm
                      prose prose-base max-w-none
            ${isUser ? "bg-black text-white prose-invert" : "bg-white border text-gray-900"}`}
        >
          {/* ✅ Render attachments */}
          {attachments.length > 0 && (
            <div className="mb-2 flex flex-wrap gap-2">
              {attachments.map((att) => (
                <div
                  key={`${att.sessionId || "global"}:${att.source || att.name}`}
                  className={`border rounded px-2 py-1 text-sm flex items-center gap-2 ${
                    isUser
                      ? "bg-white/10 border-white/30"
                      : "bg-white"
                  }`}
                  title={att.name || att.source}
                >
                  📎 <span className="truncate max-w-[220px]">{att.name}</span>
                </div>
              ))}
            </div>
          )}

          {content ? (
            <div className="max-w-full">
              <MarkdownMessage text={content} />
            </div>
          ) : hasOnlyAttachments ? null : isUser ? null : (
            <span className="opacity-60">…</span>
          )}
        </div>
      </div>

      {showActions && (
        <div className={`mt-1 flex ${isUser ? "justify-end" : "justify-start"}`}>
          <div className="flex items-center gap-2">
            <button
              type="button"
              onClick={copyWholeMessage}
              title={copiedMsg ? "Copied" : "Copy"}
              aria-label={copiedMsg ? "Copied" : "Copy message"}
              className="inline-flex items-center justify-center w-7 h-7 rounded border
                         bg-white text-gray-700 shadow-sm hover:bg-gray-50 transition"
            >
              {copiedMsg ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
            </button>
            {onDelete && (
              <button
                type="button"
                onClick={onDelete}
                title="Delete message"
                aria-label="Delete message"
                className="inline-flex items-center justify-center w-7 h-7 rounded border
                           bg-white text-gray-700 shadow-sm hover:bg-gray-50 transition"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            )}
          </div>
        </div>
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatComposer.tsx =====

// frontend/src/file_read/components/ChatComposer.tsx
import { useEffect, useRef, useState } from "react";
import ComposerActions from "./Composer/ComposerActions";
import AttachmentChip from "./Composer/AttachmentChip";
import { useAttachmentUploads } from "../hooks/useAttachmentUploads";
import type { Attachment } from "../types/chat";
import type { UIAttachment } from "../hooks/useAttachmentUploads";

const FORCE_SCROLL_EVT = "chat:force-scroll-bottom";

type Props = {
  input: string;
  setInput: (v: string) => void;
  loading: boolean;
  queued?: boolean;
  onSend: (text: string, attachments?: Attachment[]) => void | Promise<void>;
  onStop: () => void | Promise<void>;
  onHeightChange?: (h: number) => void;
  onRefreshChats?: () => void;
  sessionId?: string;
};

export default function ChatComposer({
  input,
  setInput,
  loading,
  queued = false,
  onSend,
  onStop,
  onHeightChange,
  onRefreshChats,
  sessionId,
}: Props) {
  const wrapRef = useRef<HTMLDivElement>(null);
  const taRef = useRef<HTMLTextAreaElement>(null);
  const fileRef = useRef<HTMLInputElement>(null);
  const MAX_HEIGHT_PX = 192;

  const [isClamped, setIsClamped] = useState(false);
  const [draft, setDraft] = useState(input);

  const { atts, addFiles, removeAtt, anyUploading, anyReady, attachmentsForPost, reset } =
    useAttachmentUploads(sessionId, onRefreshChats);

  useEffect(() => setDraft(input), [input]);

  const autogrow = () => {
    const ta = taRef.current;
    if (!ta) return;
    ta.style.height = "auto";
    const next = Math.min(ta.scrollHeight, MAX_HEIGHT_PX);
    ta.style.height = `${next}px`;
    setIsClamped(ta.scrollHeight > MAX_HEIGHT_PX);
    if (wrapRef.current && onHeightChange) {
      onHeightChange(wrapRef.current.getBoundingClientRect().height);
    }
  };

  useEffect(() => {
    autogrow();
    const onResize = () => autogrow();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  useEffect(() => {
    autogrow();
  }, [draft, atts.length]);

  const hasText = draft.trim().length > 0;

  const forceScroll = (behavior: ScrollBehavior = "auto") => {
    window.dispatchEvent(new CustomEvent(FORCE_SCROLL_EVT, { detail: { behavior } }));
  };

  const handleSendClick = async () => {
    const v = draft.trim();
    if ((loading || queued) || (!v && !anyReady) || anyUploading) return;
    forceScroll("auto");
    setDraft("");
    setInput("");
    reset();
    try {
      await onSend(v, attachmentsForPost());
    } finally {
      onRefreshChats?.();
      requestAnimationFrame(() => forceScroll("smooth"));
    }
  };

  const handleStopClick = () => {
    if (!loading && !queued) return;
    void Promise.resolve(onStop()).finally(() => onRefreshChats?.());
  };

  const pickFile = () => fileRef.current?.click();

  const onFilePicked: React.ChangeEventHandler<HTMLInputElement> = async (e) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    if (!sessionId) {
      e.target.value = "";
      return;
    }
    await addFiles(files);
    e.target.value = "";
  };

  function onKeyDown(e: React.KeyboardEvent<HTMLTextAreaElement>) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      void handleSendClick();
    }
  }

  const disableActions = loading || queued || anyUploading;
  const showSend = hasText || anyReady;

  return (
    <div ref={wrapRef} className="relative z-50 bg-white/95 backdrop-blur border-t p-3">
      {atts.length > 0 && (
        <div className="mb-2 flex flex-wrap gap-2">
          {atts.map((a: UIAttachment) => (
            <AttachmentChip key={a.uiId} a={a} onRemove={removeAtt} />
          ))}
        </div>
      )}

      <div className="flex gap-2">
        <input ref={fileRef} type="file" multiple className="hidden" onChange={onFilePicked} />

        <textarea
          ref={taRef}
          value={draft}
          onChange={(e) => {
            setDraft(e.target.value);
            setInput(e.target.value);
            autogrow();
          }}
          onInput={autogrow}
          onKeyDown={onKeyDown}
          placeholder="Ask anything…"
          className={`flex-1 border rounded-lg px-3 py-2 resize-none focus:outline-none focus:ring ${
            isClamped ? "overflow-y-auto" : "overflow-hidden"
          }`}
          rows={1}
          style={{ maxHeight: MAX_HEIGHT_PX }}
          disabled={queued}
        />

        <ComposerActions
          disabledUpload={disableActions || !sessionId}
          onPickFile={pickFile}
          showStop={loading || queued}
          onStop={handleStopClick}
          showSend={showSend}
          onSend={handleSendClick}
        />
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatContainer.tsx =====

// frontend/src/file_read/components/ChatContainer.tsx
import { useState, useRef, useEffect, useMemo } from "react";
import ChatView from "./ChatView/ChatView";
import ChatComposer from "./ChatComposer";
import BudgetBar from "./Budget/BudgetBar";
import type { ChatMsg } from "../types/chat";
import type { GenMetrics, RunJson } from "../shared/lib/runjson";
import type { Attachment } from "../types/chat";

interface Props {
  messages: ChatMsg[];
  input: string;
  setInput: (s: string) => void;
  loading: boolean;
  queued?: boolean;
  send: (text?: string, attachments?: Attachment[]) => Promise<void>;
  stop: () => Promise<void> | void;
  runMetrics?: GenMetrics | null;
  runJson?: RunJson | null;
  onRefreshChats?: () => void;
  onDeleteMessages?: (ids: string[]) => void;
  autoFollow?: boolean;
  sessionId?: string;
}

export default function ChatContainer({
  messages,
  input,
  setInput,
  loading,
  queued = false,
  send,
  stop,
  runMetrics,
  runJson,
  onRefreshChats,
  onDeleteMessages,
  autoFollow = true,
  sessionId,
}: Props) {
  const [composerH, setComposerH] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  const [pinned, setPinned] = useState(false);

  useEffect(() => {
    const el = containerRef.current;
    if (!el) return;
    const threshold = 120;
    const isNearBottom = () => el.scrollHeight - el.scrollTop - el.clientHeight <= threshold;
    const onScroll = () => setPinned(!isNearBottom());
    el.addEventListener("scroll", onScroll, { passive: true });
    setPinned(!isNearBottom());
    return () => el.removeEventListener("scroll", onScroll);
  }, []);

  const forceScrollToBottom = (behavior: ScrollBehavior = "smooth") => {
    const el = containerRef.current;
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior });
  };

  const handleSend = async (text?: string, attachments?: Attachment[]) => {
    if (!pinned) forceScrollToBottom("auto");
    await send(text, attachments);
    onRefreshChats?.();
    if (!pinned) requestAnimationFrame(() => forceScrollToBottom("smooth"));
  };

  const runJsonForBar = useMemo<RunJson | null>(() => {
    if (runJson) return runJson;
    for (let i = messages.length - 1; i >= 0; i--) {
      const m: any = messages[i];
      if (m?.role === "assistant" && m?.meta?.runJson) return m.meta.runJson as RunJson;
    }
    return null;
  }, [runJson, messages]);

  return (
    <div className="flex flex-col h-full border rounded-lg overflow-hidden bg-white">
      <div ref={containerRef} data-chat-scroll className="flex-1 overflow-y-auto min-w-0">
        <ChatView
          messages={messages}
          loading={loading}
          queued={queued}
          bottomPad={composerH}
          runMetrics={runMetrics}
          runJson={runJson}
          onDeleteMessages={onDeleteMessages}
          autoFollow={autoFollow}
        />
      </div>

      <BudgetBar runJson={runJsonForBar ?? null} />

      <ChatComposer
        input={input}
        setInput={setInput}
        loading={loading}
        queued={queued}
        onSend={handleSend}
        onStop={stop}
        onHeightChange={setComposerH}
        onRefreshChats={onRefreshChats}
        sessionId={sessionId}
      />
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatItem.tsx =====

// frontend/src/file_read/components/chat/ChatItem.tsx
import ChatBubble from "./ChatBubble";
import AssistantMetrics from "./AssistantMetrics";
import { buildStatus } from "./ChatView/StatusLine";
import type { ChatMsg } from "../types/chat";
import type { RunJson, GenMetrics } from "../shared/lib/runjson";

export default function ChatItem({
  m,
  idx,
  loading,
  lastAssistantIndex,
  runJsonLive,
  runMetricsLive,
  onDelete,
}: {
  m: ChatMsg;
  idx: number;
  loading: boolean;
  lastAssistantIndex: number;
  runJsonLive?: RunJson | null;
  runMetricsLive?: GenMetrics | null;
  onDelete?: (id: string) => void;
}) {
  const isAssistant = m.role === "assistant";
  const isCurrentStreamingAssistant = isAssistant && loading && idx === lastAssistantIndex;

  let jsonForThis: RunJson | null = null;
  let flatForThis: GenMetrics | null = null;

  if (isAssistant) {
    // @ts-ignore meta bag
    const meta = m.meta as { runJson?: RunJson | null; flat?: GenMetrics | null } | undefined;
    jsonForThis = meta?.runJson ?? null;
    flatForThis = meta?.flat ?? null;

    if (isCurrentStreamingAssistant) {
      if (runJsonLive) jsonForThis = runJsonLive;
      if (runMetricsLive) flatForThis = runMetricsLive;
    }
  }

  const status = isAssistant ? buildStatus(jsonForThis, flatForThis) : "";
  const showMetrics = isAssistant && (jsonForThis || flatForThis);

  return (
    <div>
      <ChatBubble
        role={m.role}
        text={m.text}
        attachments={m.attachments} 
        showActions={m.role === "user" || (m.role === "assistant" && !isCurrentStreamingAssistant)}
        onDelete={onDelete ? () => onDelete(m.id) : undefined}
      />
      {showMetrics && <AssistantMetrics status={status} runJson={jsonForThis} flat={flatForThis} />}
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatSidebar/AccountPanel.tsx =====

// frontend/src/file_read/components/ChatSidebar/AccountPanel.tsx
import { useEffect, useMemo, useState } from "react";
import { ChevronDown, LogOut, Settings, HelpCircle, Stars, BookOpen, Wand2, Save } from "lucide-react";
import { useAuth } from "../../auth/AuthContext";

function initials(s: string) {
  const parts = (s || "").trim().split(/\s+/);
  if (!parts[0]) return "AC";
  if (parts.length === 1) return parts[0].slice(0, 2).toUpperCase();
  return (parts[0][0] + parts[1][0]).toUpperCase();
}

export default function AccountPanel() {
  const { user, setToken } = useAuth(); // local auth context
  const [open, setOpen] = useState(false);

  // --- identity display (prefer context; fallback to localStorage) ---
  const storedEmail = typeof localStorage !== "undefined" ? localStorage.getItem("profile_email") || "" : "";
  const display = user?.email || storedEmail || "Account";
  const tier = "Pro";
  const avatarText = useMemo(() => initials(display), [display]);

  // --- license key management (used by proxy / app limits) ---
  const [license, setLicense] = useState<string>("");
  const [saved, setSaved] = useState<null | "ok" | "err">(null);

  useEffect(() => {
    try {
      setLicense(localStorage.getItem("license_key") || "");
    } catch {
      /* ignore */
    }
  }, []);

  function saveLicense() {
    try {
      if (license.trim()) {
        localStorage.setItem("license_key", license.trim());
      } else {
        localStorage.removeItem("license_key");
      }
      setSaved("ok");
      setTimeout(() => setSaved(null), 1500);
    } catch {
      setSaved("err");
      setTimeout(() => setSaved(null), 2000);
    }
  }

  // --- actions ---
  function openSettings() {
    try { window.dispatchEvent(new CustomEvent("open:settings")); } catch {}
    setOpen(false);
  }
  function openKnowledge() {
    try { window.dispatchEvent(new CustomEvent("open:knowledge")); } catch {}
    setOpen(false);
  }
  function openCustomize() {
    try { window.dispatchEvent(new CustomEvent("open:customize")); } catch {}
    setOpen(false);
  }
  function openHelp() {
    // Swap with your docs/help URL
    window.open("https://yourdocs.example.com", "_blank", "noopener,noreferrer");
    setOpen(false);
  }
  function logout() {
    try {
      localStorage.removeItem("local_jwt");
      // keep profile_email / license_key unless you want to clear them too
      setToken?.(null);
    } finally {
      setOpen(false);
      // Simple UX: reload to reset state everywhere
      location.reload();
    }
  }

  return (
    <div className="p-2">
      <button
        onClick={() => setOpen((v) => !v)}
        className="w-full flex items-center gap-3 bg-gray-100 hover:bg-gray-200 active:bg-gray-300 transition rounded-xl px-3 py-2 text-left"
        aria-haspopup="menu"
        aria-expanded={open}
      >
        <div className="w-8 h-8 rounded-lg bg-slate-800 text-white grid place-items-center text-xs font-semibold">
          {avatarText}
        </div>
        <div className="min-w-0 flex-1">
          <div className="text-sm font-medium truncate">{display}</div>
          <div className="text-[11px] text-gray-600">
            <span className="inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-[10px]">
              {tier}
            </span>
          </div>
        </div>
        <ChevronDown className={`w-4 h-4 transition ${open ? "rotate-180" : ""}`} />
      </button>

      {open && (
        <div className="hidden md:block relative">
          <div className="fixed inset-0 z-30" onClick={() => setOpen(false)} aria-hidden />
          <div role="menu" className="absolute z-40 bottom-14 left-2 right-2 rounded-xl border bg-white shadow-xl overflow-hidden">
            <div className="px-3 py-2 text-xs text-gray-600 border-b truncate">{display}</div>

            {/* License Key (for proxy/app rate-limits) */}
            <div className="px-3 py-3 border-b bg-gray-50/60">
              <div className="text-[11px] font-medium text-gray-600 mb-1">License key</div>
              <div className="flex items-center gap-2">
                <input
                  value={license}
                  onChange={(e) => setLicense(e.target.value)}
                  placeholder="paste-your-key"
                  className="flex-1 rounded-lg border px-3 py-2 text-sm outline-none focus:ring-2 focus:ring-black"
                  spellCheck={false}
                />
                <button
                  onClick={saveLicense}
                  className="inline-flex items-center gap-1 rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
                >
                  <Save size={16} /> Save
                </button>
              </div>
              {saved === "ok" && <div className="mt-1 text-[11px] text-green-600">Saved</div>}
              {saved === "err" && <div className="mt-1 text-[11px] text-red-600">Couldn’t save</div>}
            </div>

            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50" onClick={() => { setOpen(false); }}>
              <Stars className="w-4 h-4" /> Upgrade plan
            </button>
            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50" onClick={openCustomize}>
              <Wand2 className="w-4 h-4" /> Customize
            </button>
            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50" onClick={openKnowledge}>
              <BookOpen className="w-4 h-4" /> Knowledge
            </button>
            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50" onClick={openSettings}>
              <Settings className="w-4 h-4" /> Settings
            </button>
            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50" onClick={openHelp}>
              <HelpCircle className="w-4 h-4" /> Help
            </button>
            <button className="w-full flex items-center gap-2 px-3 py-2 text-sm hover:bg-gray-50 text-red-600" onClick={logout}>
              <LogOut className="w-4 h-4" /> Log out
            </butto