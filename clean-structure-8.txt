rom "../data/chatApi";
import { extractRunJsonFromBuffer } from "../shared/lib/runjson";

function rowToMsg(r: ChatMessageRow): ChatMsg {
  if (r.role === "assistant") {
    const { clean, json, flat } = extractRunJsonFromBuffer(r.content);
    const base: ChatMsg = {
      id: `cid-${r.id}`,
      serverId: r.id,
      role: r.role,
      text: clean,
      attachments: r.attachments ?? [],
    };
    if (json || flat) base.meta = { runJson: json ?? null, flat: flat ?? null };
    return base;
  }

  // user
  return {
    id: `cid-${r.id}`,
    serverId: r.id,
    role: r.role,
    text: r.content,
    attachments: r.attachments ?? [],
  };
}

export function useSession(opts: {
  setMessagesForSession: (sid: string, msgs: ChatMsg[]) => void;
  getMessagesForSession: (sid: string) => ChatMsg[];
  isStreaming: (sid: string) => boolean;
}) {
  const { setMessagesForSession, getMessagesForSession, isStreaming } = opts;
  const sessionIdRef = useRef<string>(crypto.randomUUID());
  const hasCreatedRef = useRef(false);

  async function ensureChatCreated() {
    if (!sessionIdRef.current) {
      sessionIdRef.current = crypto.randomUUID();
      hasCreatedRef.current = false;
    }
    if (hasCreatedRef.current) return;
    try {
      await createChat(sessionIdRef.current, "New Chat");
      hasCreatedRef.current = true;
      if (!getMessagesForSession(sessionIdRef.current)?.length) {
        setMessagesForSession(sessionIdRef.current, []); // initialize
      }
    } catch (e) {
      console.warn("createChat failed:", e);
    }
  }


   async function loadHistory(sessionId: string): Promise<void> {
    sessionIdRef.current = sessionId;
    hasCreatedRef.current = true;

    try {
      const rows = await listMessages(sessionId);
      const serverMsgs = rows.map(rowToMsg);
      const prevClient = getMessagesForSession(sessionId) ?? [];

      if (isStreaming(sessionId)) {
        const byServer = new Map<number, ChatMsg>(
          prevClient
            .filter((m) => m.serverId != null)
            .map((m) => [m.serverId as number, m]),
        );
        const merged = serverMsgs.map((s) => {
          const prev = byServer.get(s.serverId!);
          if (!prev) return s;
          const meta = s.meta ?? prev.meta ?? undefined;
          return { ...prev, ...s, meta };
        });

        const tail: ChatMsg[] = [];
        const last = prevClient[prevClient.length - 1];
        if (
          last?.role === "assistant" &&
          (last.text?.length ?? 0) > 0 &&
          last.serverId == null
        ) {
          tail.push(last);
        }

        setMessagesForSession(sessionId, [...merged, ...tail]);
      } else {
        // If we have optimistic client messages and server has nothing useful yet,
        // keep the client view intact until the assistant turn is persisted.
        const hasOptimistic = prevClient.some((m) => m.serverId == null);
        const serverHasAssistant =
          serverMsgs.some((m) => m.role === "assistant" && (m.text?.trim()?.length ?? 0) > 0);

        if (hasOptimistic && !serverHasAssistant) {
          return; // do not clobber the optimistic view
        }

        setMessagesForSession(sessionId, serverMsgs);
      }
    } catch (e) {
      console.warn("listMessages failed:", e);
      if (!isStreaming(sessionId)) setMessagesForSession(sessionId, []);
    }
  }


  function setSessionId(newId: string) {
    sessionIdRef.current = newId;
    hasCreatedRef.current = false;
    setMessagesForSession(newId, []);
  }

  function resetSession() {
    const id = sessionIdRef.current;
    if (id) setMessagesForSession(id, []);
  }

  return {
    sessionIdRef,
    ensureChatCreated,
    loadHistory,
    setSessionId,
    resetSession,
  };
}

# ===== frontend/src/hooks/useSettings.ts =====

import { useCallback, useEffect, useMemo, useState } from "react";
import {
  getEffective,
  getOverrides,
  getDefaults,
  getAdaptive,
  patchOverrides,
  putOverrides,
  recomputeAdaptive,
} from "../data/settingsApi";

type State = {
  loading: boolean;
  error: string | null;
  effective: any | null;
  overrides: any | null;
  defaults: any | null;
  adaptive: any | null;
};

export function useSettings(sessionId?: string) {
  const [state, setState] = useState<State>({
    loading: false,
    error: null,
    effective: null,
    overrides: null,
    defaults: null,
    adaptive: null,
  });

  const load = useCallback(async () => {
    setState((s) => ({ ...s, loading: true, error: null }));
    try {
      const [effective, overrides, defaults, adaptive] = await Promise.all([
        getEffective(sessionId),
        getOverrides(),
        getDefaults(),
        getAdaptive(),
      ]);
      setState({
        loading: false,
        error: null,
        effective,
        overrides,
        defaults,
        adaptive,
      });
    } catch (e: any) {
      setState((s) => ({
        ...s,
        loading: false,
        error: e?.message || "Failed to load settings",
      }));
    }
  }, [sessionId]);

  useEffect(() => {
    void load();
  }, [load]);

  const saveOverrides = useCallback(
    async (data: Record<string, any>, method: "patch" | "put" = "patch") => {
      if (method === "put") await putOverrides(data);
      else await patchOverrides(data);
      await load();
    },
    [load],
  );

  const runAdaptive = useCallback(async () => {
    await recomputeAdaptive(sessionId);
    await load();
  }, [load, sessionId]);

  return useMemo(
    () => ({
      ...state,
      reload: load,
      saveOverrides,
      runAdaptive,
    }),
    [state, load, saveOverrides, runAdaptive],
  );
}

# ===== frontend/src/hooks/useSidebar.ts =====

// frontend/src/file_read/hooks/useSidebar.ts
import { useEffect, useState } from "react";

export function useSidebar() {
  const [sidebarOpen, setSidebarOpen] = useState(
    () => window.innerWidth >= 768,
  );

  // pin on desktop
  useEffect(() => {
    const onResize = () => {
      if (window.innerWidth >= 768) setSidebarOpen(true);
    };
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  }, []);

  // Ctrl+B toggle
  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.ctrlKey && (e.key === "b" || e.key === "B")) {
        e.preventDefault();
        setSidebarOpen((v) => !v);
      }
    };
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, []);

  // mobile drawer helpers (DOM-level; safe here)
  const openMobileDrawer = () => {
    document.getElementById("mobile-drawer")?.classList.remove("hidden");
    document.getElementById("mobile-backdrop")?.classList.remove("hidden");
    document.body.style.overflow = "hidden";
  };
  const closeMobileDrawer = () => {
    document.getElementById("mobile-drawer")?.classList.add("hidden");
    document.getElementById("mobile-backdrop")?.classList.add("hidden");
    document.body.style.overflow = "";
  };

  return {
    sidebarOpen,
    setSidebarOpen,
    openMobileDrawer,
    closeMobileDrawer,
  };
}

# ===== frontend/src/hooks/useStream.ts =====

import { useEffect, useMemo, useRef, useState } from "react";
import type { ChatMsg } from "../types/chat";
import type { RunJson, GenMetrics } from "../shared/lib/runjson";
import { createStreamController } from "./stream/core/controller";
import type { Attachment } from "../types/chat";

type UseStreamDeps = {
  // not read directly; keeps memo deps stable
  messages: ChatMsg[];

  // message state per session
  setMessagesForSession: (
    sid: string,
    updater: (prev: ChatMsg[]) => ChatMsg[],
  ) => void;
  getMessagesForSession: (sid: string) => ChatMsg[];

  // ui
  setInput: (v: string) => void;

  // session plumbing
  sessionId: () => string;
  ensureChatCreated: () => Promise<void>;
  onRetitle: (sessionId: string, latestAssistant: string) => Promise<void>;

  // per-session flags/metrics
  setLoadingForSession: (sid: string, v: boolean) => void;
  setQueuedForSession?: (sid: string, v: boolean) => void;
  setMetricsForSession: (
    sid: string,
    json?: RunJson,
    flat?: GenMetrics,
  ) => void;
  setMetricsFallbackForSession: (
    sid: string,
    reason: string,
    partialOut: string,
  ) => void;
  resetMetricsForSession: (sid: string) => void;
};

export function useStream({
  setMessagesForSession,
  getMessagesForSession,
  setInput,
  sessionId,
  ensureChatCreated,
  onRetitle,
  setLoadingForSession,
  setQueuedForSession,
  setMetricsForSession,
  setMetricsFallbackForSession,
  resetMetricsForSession,
}: UseStreamDeps) {
  const [loading, setLoading] = useState(false);
  const controllerRef = useRef<ReturnType<
    typeof createStreamController
  > | null>(null);

  const controller = useMemo(() => {
    return createStreamController({
      // message access
      getMessagesFor: (sid) => getMessagesForSession(sid),
      setMessagesFor: (sid, updater) => setMessagesForSession(sid, updater),

      // ui hooks
      setInput: () => setInput(""),
      setLoadingFor: (sid, v) => {
        if (sid === sessionId()) setLoading(v);
        setLoadingForSession(sid, v);
      },
      setQueuedFor: setQueuedForSession ?? (() => {}),

      // metrics
      setMetricsFor: (sid, json, flat) => setMetricsForSession(sid, json, flat),
      setMetricsFallbackFor: (sid, reason, out) =>
        setMetricsFallbackForSession(sid, reason, out),

      // patch server id onto a bubble identified by clientId
      setServerIdFor: (sid, clientId, serverId) => {
        setMessagesForSession(sid, (prev) => {
          const list = prev || [];
          return list.map((m) => (m.id === clientId ? { ...m, serverId } : m));
        });
      },

      // session plumbing
      getSessionId: sessionId,
      ensureChatCreated,
      onRetitle,
      resetMetricsFor: (sid) => resetMetricsForSession(sid),
    });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    controllerRef.current = controller;
    return () => controllerRef.current?.dispose();
  }, [controller]);

  async function send(override?: string, attachments: Attachment[] = []) {
    const text = (override ?? "").trim();
    if (!text && attachments.length === 0) return;
    await controller.send(text, attachments);
  }

  async function stop() {
    await controller.stop();
  }

  async function cancelBySessionId(sid: string) {
    await controller.cancelBySessionId(sid);
  }

  return { loading, send, stop, cancelBySessionId };
}

# ===== frontend/src/hooks/useToast.ts =====

import { useState } from "react";

export function useToast() {
  const [toast, setToast] = useState<string | null>(null);
  function show(msg: string, ms = 1800) {
    setToast(msg);
    window.clearTimeout((show as any)._t);
    (show as any)._t = window.setTimeout(() => setToast(null), ms);
  }
  return { toast, show };
}

# ===== frontend/src/index.css =====

/* index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Safe-area + dynamic viewport */
:root{
  --safe-bottom: env(safe-area-inset-bottom, 0px);
  --safe-top:    env(safe-area-inset-top, 0px);
}

html, body, #root { min-height: 100dvh; }

/* Reusable helpers */
@layer utilities {
  /* pad bottom enough so last items aren't under the Android bar */
  .pb-safe { padding-bottom: calc(var(--safe-bottom) + 12px) !important; }

  /* if you used h-screen/min-h-screen anywhere, map them to dynamic vh */
  .h-screen     { height: 100dvh !important; }
  .min-h-screen { min-height: 100dvh !important; }
}

# ===== frontend/src/main.tsx =====

import "./polyfills"; // âœ… must be very first

import { StrictMode } from "react";
import "./index.css";
import { createRoot } from "react-dom/client";
import App from "./App";
import { AuthProvider } from "./auth/AuthContext";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <AuthProvider>
      <App />
    </AuthProvider>
  </StrictMode>,
);

# ===== frontend/src/pages/AgentRunner.tsx =====

import { useEffect, useState } from "react";
import { useChatStream } from "../hooks/useChatStream";
import { useSidebar } from "../hooks/useSidebar";
import { useToast } from "../hooks/useToast";
import { createChat, deleteMessagesBatch } from "../data/chatApi";
import { useAuth } from "../auth/AuthContext";
import { getModelHealth } from "../api/models";
import { getJSON } from "../services/http"; // removed postJSON
import type { Attachment } from "../types/chat";
import AgentRunnerView from "./AgentRunnerView";

const LS_KEY = "lastSessionId";

export default function AgentRunner() {
  const chat = useChatStream();
  const [showKnowledge, setShowKnowledge] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);
  const [autoFollow, setAutoFollow] = useState(true);
  const { toast, show } = useToast();
  const { sidebarOpen, setSidebarOpen, openMobileDrawer, closeMobileDrawer } = useSidebar();
  const [showSettings, setShowSettings] = useState(false);

  // LM-Studioâ€“style model picker
  const [showModelPicker, setShowModelPicker] = useState(false);

  // Auth â†’ refresh chat list after /auth/me resolves
  const { user, loading } = useAuth();
  useEffect(() => {
    if (!loading && user) setRefreshKey((k) => k + 1);
  }, [loading, user]);

  // ---- Single-runtime health ----
  const [health, setHealth] = useState<{ ok: boolean; loaded: boolean; config: any } | null>(null);
  const singleRuntimeLoaded = !!health?.loaded;
  const singleRuntimeModelName =
    (health?.config?.config?.modelPath || health?.config?.modelPath || "")
      .split(/[\\/]/)
      .pop() || null;

  useEffect(() => {
    let alive = true;
    let t: any;
    const poll = async () => {
      try {
        const h = await getModelHealth();
        if (alive) setHealth(h);
      } catch {
        if (alive) setHealth({ ok: false, loaded: false, config: null });
      } finally {
        t = setTimeout(poll, 40000);
      }
    };
    poll();
    return () => {
      alive = false;
      clearTimeout(t);
    };
  }, []);

  // ---- Worker readiness (active+ready) ----
  const [workerActiveReady, setWorkerActiveReady] = useState(false);
  const [workerModelName, setWorkerModelName] = useState<string | null>(null);

  async function refreshWorkerReady() {
    try {
      const info = await getJSON<{ ok: boolean; workers: any[]; active: string | null }>(
        "/api/model-workers/inspect"
      );
      const activeId = info?.active || null;
      const active = info?.workers?.find((w) => w.id === activeId) || null;
      const ready = !!active && active.status === "ready";
      setWorkerActiveReady(ready);
      if (ready && active) {
        const nm = (active.model_path || "").split(/[\\/]/).pop() || active.model_path || "";
        setWorkerModelName(nm || null);
      } else {
        setWorkerModelName(null);
      }
    } catch {
      setWorkerActiveReady(false);
      setWorkerModelName(null);
    }
  }

  useEffect(() => {
    let alive = true;
    let t: any;
    const poll = async () => {
      if (!alive) return;
      await refreshWorkerReady();
      t = setTimeout(poll, 30000);
    };
    poll();
    return () => {
      alive = false;
      clearTimeout(t);
    };
  }, []);

  // ðŸ‘‡ Treat either single-runtime OR active worker as â€œreadyâ€
  const modelLoaded = singleRuntimeLoaded || workerActiveReady;
  const modelName = workerActiveReady ? workerModelName : singleRuntimeModelName;

  // Send message: unified streaming path
  async function safeSend(text?: string, attachments?: Attachment[]) {
    const raw = (text ?? chat.input ?? "").trim();

    if (!modelLoaded) {
      show("Select a model or activate a worker to start.");
      setShowModelPicker(true);
      return;
    }
    if (!raw && !(attachments && attachments.length)) return;

    // ensure session exists
    let sid = chat.sessionIdRef.current;
    if (!sid) {
      sid = crypto.randomUUID();
      chat.setSessionId(sid);
      try {
        await createChat(sid, "New Chat");
      } catch {}
      localStorage.setItem(LS_KEY, sid);
      setRefreshKey((k) => k + 1);
    }

    try {
      // always stream; backend proxies to worker if one is active
      await chat.send(raw, attachments);
    } catch (e: any) {
      const msg =
        e?.message === "MODEL_NOT_LOADED"
          ? "Model not loaded. Select a model to start."
          : e?.message || "Unable to send. Is a model loaded?";
      show(msg);
    }
  }

  // Settings/Knowledge global events
  useEffect(() => {
    const openSettings = () => setShowSettings(true);
    const openKnowledge = () => setShowKnowledge(true);
    const openCustomize = () => setShowKnowledge(true);
    window.addEventListener("open:settings", openSettings);
    window.addEventListener("open:knowledge", openKnowledge);
    window.addEventListener("open:customize", openCustomize);
    return () => {
      window.removeEventListener("open:settings", openSettings);
      window.removeEventListener("open:knowledge", openKnowledge);
      window.removeEventListener("open:customize", openCustomize);
    };
  }, []);

  // ----- Chat helpers -----
  async function newChat(): Promise<void> {
    const id = crypto.randomUUID();
    chat.setSessionId(id);
    try {
      await createChat(id, "New Chat");
    } catch {}
    localStorage.setItem(LS_KEY, id);
    setRefreshKey((k) => k + 1);
    chat.setInput("");
    chat.clearMetrics?.();
    await refreshFollow();
  }

  async function openSession(id: string): Promise<void> {
    if (!id) return;
    await chat.loadHistory(id);
    localStorage.setItem(LS_KEY, id);
    chat.setInput("");
    chat.clearMetrics?.();
    await refreshFollow();
  }

  async function refreshFollow() {
    const sid = chat.sessionIdRef.current;
    if (!sid) return;
    setAutoFollow(true);
    await chat.loadHistory(sid);
    const el = document.getElementById("chat-scroll-container");
    if (el) el.scrollTop = el.scrollHeight;
  }

  async function refreshPreserve() {
    const sid = chat.sessionIdRef.current;
    if (!sid) return;
    const el = document.getElementById("chat-scroll-container");
    const prevTop = el?.scrollTop ?? 0;
    const prevHeight = el?.scrollHeight ?? 0;
    setAutoFollow(false);
    await chat.loadHistory(sid);
    requestAnimationFrame(() => {
      if (el) {
        const newHeight = el.scrollHeight;
        el.scrollTop = prevTop + (newHeight - prevHeight);
      }
      setAutoFollow(true);
    });
  }

  async function handleCancelSessions(ids: string[]) {
    if (!ids?.length) return;
    const currentId = chat.sessionIdRef.current || "";
    const deletingActive = currentId && ids.includes(currentId);
    if (deletingActive) {
      chat.setSessionId("");
      chat.setInput("");
      chat.clearMetrics?.();
      chat.reset();
      localStorage.removeItem(LS_KEY);
    }
    setRefreshKey((k) => k + 1);
    try {
      window.dispatchEvent(new CustomEvent("chats:refresh"));
    } catch {}
  }

  async function handleDeleteMessages(clientIds: string[]) {
    const sid = chat.sessionIdRef.current;
    if (!sid || !clientIds?.length) return;
    const current = chat.messages;
    const toDelete = new Set(clientIds);
    const serverIds = current
      .filter((m: any) => toDelete.has(m.id) && m.serverId != null)
      .map((m: any) => m.serverId as number);
    const remaining = current.filter((m) => !toDelete.has(m.id));
    (chat as any).setMessagesForSession?.(sid, () => remaining);
    try {
      if (serverIds.length) {
        await deleteMessagesBatch(sid, serverIds);
      }
      await refreshPreserve();
      setRefreshKey((k) => k + 1);
      try {
        window.dispatchEvent(new CustomEvent("chats:refresh"));
      } catch {}
      show("Message deleted");
    } catch {
      show("Failed to delete message");
      await chat.loadHistory(sid);
      setRefreshKey((k) => k + 1);
    }
  }

  async function handleEjectModel() {
    try {
      await fetch("/api/models/unload", { method: "POST", credentials: "include" });
      setHealth((h) => (h ? { ...h, loaded: false } : { ok: true, loaded: false, config: null }));
    } catch {
      show("Failed to unload model");
    } finally {
      await refreshWorkerReady();
    }
  }

  async function refreshHealth() {
    try {
      const h = await getModelHealth();
      setHealth(h);
      await refreshWorkerReady();
    } catch {}
  }

  return (
    <AgentRunnerView
      // sidebar
      sidebarOpen={sidebarOpen}
      setSidebarOpen={setSidebarOpen}
      openMobileDrawer={openMobileDrawer}
      closeMobileDrawer={closeMobileDrawer}
      // chat + ui state
      chat={chat}
      toast={toast}
      autoFollow={autoFollow}
      refreshKey={refreshKey}
      // model
      modelLoaded={modelLoaded}
      modelName={modelName}
      showModelPicker={showModelPicker}
      setShowModelPicker={setShowModelPicker}
      onEjectModel={handleEjectModel}
      onHealthRefresh={refreshHealth}
      // panels
      showSettings={showSettings}
      setShowSettings={setShowSettings}
      showKnowledge={showKnowledge}
      setShowKnowledge={setShowKnowledge}
      // handlers
      onOpenSession={openSession}
      onNewChat={newChat}
      onCancelSessions={handleCancelSessions}
      onDeleteMessages={handleDeleteMessages}
      safeSend={safeSend}
      showToast={show}
    />
  );
}

# ===== frontend/src/pages/AgentRunnerView.tsx =====

// frontend/src/file_read/pages/AgentRunnerView.tsx
import DesktopHeader from "../components/DesktopHeader";
import MobileDrawer from "../components/MobileDrawer";
import Toast from "../shared/ui/Toast";
import ChatSidebar from "../components/ChatSidebar/ChatSidebar";
import ChatContainer from "../components/ChatContainer";
import SettingsPanel from "../components/SettingsPanel";
import KnowledgePanel from "../components/KnowledgePanel";
import ModelPicker from "../components/ModelPicker/ModelPicker";
import type { Attachment } from "../types/chat";

type ChatApi = {
  messages: any[];
  input: string;
  setInput: (v: string) => void;
  loading: boolean;
  queued?: boolean;
  send: (text?: string, attachments?: Attachment[]) => Promise<void>;
  stop: () => void;
  runMetrics?: any;
  runJson?: any;
  setSessionId: (id: string) => void;
  sessionIdRef: { current: string | null };
  clearMetrics?: () => void;
  loadHistory: (id: string) => Promise<void>;
  reset: () => void;
};

type Props = {
  // sidebar & drawer
  sidebarOpen: boolean;
  setSidebarOpen: (open: boolean) => void;
  openMobileDrawer: () => void;
  closeMobileDrawer: () => void;

  // chat & state
  chat: ChatApi;
  autoFollow: boolean;
  refreshKey: number;
  toast: string | null;

  // model
  modelLoaded: boolean;
  modelName: string | null;
  showModelPicker: boolean;
  setShowModelPicker: (v: boolean) => void;
  onEjectModel: () => Promise<void> | void;
  onHealthRefresh: () => Promise<void> | void;

  // panels
  showSettings: boolean;
  setShowSettings: (v: boolean) => void;
  showKnowledge: boolean;
  setShowKnowledge: (v: boolean) => void;

  // handlers
  onOpenSession: (id: string) => Promise<void>;
  onNewChat: () => Promise<void>;
  onCancelSessions: (ids: string[]) => Promise<void>;
  onDeleteMessages: (clientIds: string[]) => Promise<void>;
  safeSend: (text?: string, attachments?: Attachment[]) => Promise<void>;
  showToast: (msg: string) => void;
};

export default function AgentRunnerView({
  // sidebar & drawer
  sidebarOpen,
  setSidebarOpen,
  openMobileDrawer,
  closeMobileDrawer,

  // chat & state
  chat,
  autoFollow,
  refreshKey,
  toast,

  // model
  modelLoaded,
  modelName,
  showModelPicker,
  setShowModelPicker,
  onEjectModel,
  onHealthRefresh,

  // panels
  showSettings,
  setShowSettings,
  showKnowledge,
  setShowKnowledge,

  // handlers
  onOpenSession,
  onNewChat,
  onCancelSessions,
  onDeleteMessages,
  safeSend,
  showToast,
}: Props) {
  return (
    <div className="h-screen w-full flex bg-gray-50">
      {sidebarOpen && (
        <div className="hidden md:flex h-full">
          <ChatSidebar
            onOpen={onOpenSession}
            onNew={onNewChat}
            refreshKey={refreshKey}
            activeId={chat.sessionIdRef.current || undefined}
            onHideSidebar={() => setSidebarOpen(false)}
            onCancelSessions={onCancelSessions}
          />
        </div>
      )}

      <MobileDrawer
        onOpenSession={onOpenSession}
        onNewChat={onNewChat}
        refreshKey={refreshKey}
        activeId={chat.sessionIdRef.current || undefined}
        openMobileDrawer={openMobileDrawer}
        closeMobileDrawer={closeMobileDrawer}
      />
      <div className="md:hidden h-14 shrink-0" />

      <div className="flex-1 min-w-0 flex flex-col">
        <DesktopHeader
          sidebarOpen={sidebarOpen}
          onShowSidebar={() => setSidebarOpen(true)}
          modelLoaded={modelLoaded}
          modelName={modelName}
          busy={false}
          onOpenModelPicker={() => setShowModelPicker(true)}
          onEjectModel={onEjectModel}
        />

        {!modelLoaded && (
          <div className="px-3 md:px-6 mt-2">
            <div className="mx-auto max-w-3xl md:max-w-4xl">
              <div className="rounded-lg border bg-amber-50 text-amber-900 text-sm px-3 py-2">
                No model is loaded. Click{" "}
                <button
                  className="ml-1 inline-flex items-center text-xs px-2 py-1 rounded border hover:bg-amber-100"
                  onClick={() => setShowModelPicker(true)}
                >
                  Select a model to load
                </button>{" "}
                to start chatting.
              </div>
            </div>
          </div>
        )}

        <div className="flex-1 min-h-0">
          <div className="h-full px-3 md:px-6">
            <div className="h-full w-full mx-auto max-w-3xl md:max-w-4xl relative">
              <div id="chat-scroll-container" className="h-full">
                <ChatContainer
                  messages={chat.messages}
                  input={chat.input}
                  setInput={chat.setInput}
                  loading={chat.loading}
                  queued={chat.queued}
                  send={safeSend}
                  stop={chat.stop}
                  runMetrics={chat.runMetrics}
                  runJson={chat.runJson}
                  onRefreshChats={() => {}}
                  onDeleteMessages={onDeleteMessages}
                  autoFollow={autoFollow}
                  sessionId={chat.sessionIdRef.current || undefined}
                />
              </div>
              <Toast message={toast} />
            </div>
          </div>
        </div>
      </div>

      {showModelPicker && (
        <ModelPicker
          open={showModelPicker}
          onClose={() => setShowModelPicker(false)}
          onLoaded={onHealthRefresh}
        />
      )}

      {showSettings && (
        <SettingsPanel
          sessionId={chat.sessionIdRef.current || undefined}
          onClose={() => setShowSettings(false)}
        />
      )}
      {showKnowledge && (
        <KnowledgePanel
          sessionId={chat.sessionIdRef.current || undefined}
          onClose={() => setShowKnowledge(false)}
          toast={showToast}
        />
      )}
    </div>
  );
}

# ===== frontend/src/polyfills.ts =====

// src/polyfills.ts
(function () {
  const g: any = typeof globalThis !== "undefined" ? globalThis : window;

  if (!g.crypto) g.crypto = {};

  if (!g.crypto.getRandomValues) {
    g.crypto.getRandomValues = (arr: Uint8Array) => {
      for (let i = 0; i < arr.length; i++)
        arr[i] = Math.floor(Math.random() * 256);
      return arr;
    };
  }

  if (!g.crypto.randomUUID) {
    g.crypto.randomUUID = function () {
      const bytes = new Uint8Array(16);
      g.crypto.getRandomValues(bytes);
      // RFC 4122 v4
      bytes[6] = (bytes[6] & 0x0f) | 0x40;
      bytes[8] = (bytes[8] & 0x3f) | 0x80;
      const hex = Array.from(bytes, (b) =>
        b.toString(16).padStart(2, "0"),
      ).join("");
      return `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-${hex.slice(16, 20)}-${hex.slice(20)}`;
    };
  }
})();

# ===== frontend/src/services/http.ts =====

import { getAuth } from "firebase/auth"; 

export const API_BASE = (import.meta.env.VITE_API_URL || "/api").trim();

export function buildUrl(path: string) {
  if (/^https?:\/\//i.test(path)) return path;

  const base = API_BASE.replace(/\/+$/, "");
  const p = (path.startsWith("/") ? path : `/${path}`).replace(/\/{2,}/g, "/");

  if (/^https?:\/\//i.test(base)) {
    return new URL(p, base + "/").toString();
  }
  if (base && p.startsWith(base + "/")) return p;
  return `${base}${p}`;
}
type JSONValue = unknown;

export class HttpError extends Error {
  status: number;
  body?: string;
  constructor(status: number, message: string, body?: string) {
    super(message);
    this.status = status;
    this.body = body;
  }
}

const BYPASS = (import.meta.env.VITE_BYPASS_AUTH || "false").toLowerCase() === "true";

async function buildHeaders(init: RequestInit = {}) {
  const headers = new Headers(init.headers || {});
  if (!headers.has("Accept")) headers.set("Accept", "application/json");
  if (!headers.has("Content-Type") && typeof init.body === "string") {
    try { JSON.parse(init.body); headers.set("Content-Type", "application/json"); } catch {}
  }
  if (!headers.has("Authorization")) {
    if (BYPASS) {
      headers.set("Authorization", "Bearer dev-local");
    } else {
      try {
        const u = getAuth().currentUser;
        if (u) {
          const tok = await u.getIdToken(false);
          if (tok) headers.set("Authorization", `Bearer ${tok}`);
        }
      } catch {}
    }
  }
  return headers;
}




async function doFetch(
  path: string,
  init: RequestInit = {},
  timeoutMs = 30000,
) {
  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(), timeoutMs);
  try {
    const headers = await buildHeaders(init);
    const res = await fetch(buildUrl(path), {
      ...init,
      headers,
      // cookies for same-origin calls; still fine if API_BASE is absolute
      credentials: "include",
      signal: controller.signal,
    });
    return res;
  } finally {
    clearTimeout(t);
  }
}

export async function requestRaw(
  path: string,
  init: RequestInit = {},
  timeoutMs = 30000,
): Promise<Response> {
  return await doFetch(path, init, timeoutMs);
}

export async function request<T = JSONValue>(
  path: string,
  init: RequestInit = {},
  timeoutMs = 30000,
): Promise<T> {
  const res = await requestRaw(path, init, timeoutMs);
  const text = await res.text().catch(() => "");
  if (!res.ok) {
    let msg = res.statusText || "Request failed";
    try {
      const parsed = text ? JSON.parse(text) : undefined;
      msg = (parsed?.detail || parsed?.message || msg) as string;
    } catch {}
    throw new HttpError(res.status, `HTTP ${res.status} â€“ ${msg}`, text);
  }
  if (!text) return undefined as unknown as T;
  try {
    return JSON.parse(text) as T;
  } catch {
    return text as unknown as T;
  }
}

export const getJSON = <T = JSONValue>(path: string, init: RequestInit = {}) =>
  request<T>(path, { ...init, method: "GET" });

export const delJSON = <T = JSONValue>(path: string, init: RequestInit = {}) =>
  request<T>(path, { ...init, method: "DELETE" });

export const postJSON = <T = JSONValue>(
  path: string,
  body: unknown,
  init: RequestInit = {},
) =>
  request<T>(path, {
    ...init,
    method: "POST",
    headers: { ...(init.headers || {}), "Content-Type": "application/json" },
    body: JSON.stringify(body ?? {}),
  });

export const putJSON = <T = JSONValue>(
  path: string,
  body: unknown,
  init: RequestInit = {},
) =>
  request<T>(path, {
    ...init,
    method: "PUT",
    headers: { ...(init.headers || {}), "Content-Type": "application/json" },
    body: JSON.stringify(body ?? {}),
  });

export const postJSONWithCreds = <T = unknown>(
  path: string,
  body: unknown,
  init: RequestInit = {},
) =>
  request<T>(path, {
    ...init,
    method: "POST",
    credentials: "same-origin",
    headers: { ...(init.headers || {}), "Content-Type": "application/json" },
    body: JSON.stringify(body ?? {}),
  });

# ===== frontend/src/shared/lib/runjson.helpers.ts =====

// frontend/src/file_read/components/shared/lib/runjson.helpers.ts
import {
  MET_START,
  MET_END,
  type RunJson,
  type GenMetrics,
  type BudgetViewJson,
  type TurnBudgetJson,
  type NormalizedBudget,
  type RagTelemetry,
  type WebTelemetry,
  type PackTelemetry,
  type BudgetBreakdown,
} from "./runjson.types";

export function extractRunJsonFromBuffer(buf: string): {
  clean: string;
  json?: RunJson;
  flat?: GenMetrics;
} {
  const re = /(?:\s*)\[\[RUNJSON\]\]\s*([\s\S]*?)\s*\[\[\/RUNJSON\]\](?:\s*)/g;
  let match: RegExpExecArray | null = null;
  let last: RegExpExecArray | null = null;
  while ((match = re.exec(buf)) !== null) last = match;
  if (!last) return { clean: buf };
  const payload = last[1] ?? "";
  let parsed: RunJson | undefined;
  try {
    parsed = JSON.parse(payload) as RunJson;
  } catch {}
  const start = last.index as number;
  const end = start + last[0].length;
  const clean = buf.slice(0, start) + buf.slice(end);
  let flat: GenMetrics | undefined;
  const s = parsed?.stats;
  if (s) {
    flat = {
      ttft_ms:
        s.timeToFirstTokenSec != null
          ? Math.max(0, s.timeToFirstTokenSec) * 1000
          : null,
      tok_per_sec: s.tokensPerSecond ?? null,
      output_tokens: s.predictedTokensCount ?? null,
      input_tokens_est: s.promptTokensCount ?? null,
      total_tokens_est: s.totalTokensCount ?? null,
      stop_reason: s.stopReason ?? null,
    };
  }
  return { clean, json: parsed, flat };
}

export function stripRunJson(raw: string): {
  text: string;
  json?: RunJson;
  flat?: GenMetrics;
} {
  const { clean, json, flat } = extractRunJsonFromBuffer(raw);
  return { text: clean, json, flat };
}

export { MET_START as MET_START_TAG, MET_END as MET_END_TAG };

export function getNormalizedBudget(
  r?: RunJson | null,
): NormalizedBudget | null {
  if (!r) return null;
  const bv = r.budget_view as BudgetViewJson | null | undefined;
  if (bv && bv.modelCtx != null) {
    return {
      modelCtx: bv.modelCtx as number,
      clampMargin: (bv.clampMargin as number) ?? 0,
      inputTokensEst: (bv.inputTokensEst as number) ?? 0,
      outBudgetChosen: (bv.outBudgetChosen as number) ?? 0,
      outBudgetMaxAllowed: (bv.outBudgetMaxAllowed as number) ?? 0,
      overByTokens: (bv.overByTokens as number) ?? 0,
    };
  }
  const tb = r.stats?.budget as TurnBudgetJson | null | undefined;
  if (tb && tb.n_ctx != null) {
    const nctx = tb.n_ctx ?? 0;
    const margin = tb.clamp_margin ?? 0;
    const inp = tb.input_tokens_est ?? 0;
    const chosen = tb.clamped_out_tokens ?? 0;
    const avail = Math.max(0, nctx - inp - margin);
    return {
      modelCtx: nctx,
      clampMargin: margin,
      inputTokensEst: inp,
      outBudgetChosen: chosen,
      outBudgetMaxAllowed: Math.max(0, avail),
      overByTokens: Math.max(0, (tb.requested_out_tokens ?? chosen) - avail),
    };
  }
  return null;
}

export function getRagTelemetry(r?: RunJson | null): RagTelemetry | null {
  if (!r) return null;
  const bv = r.budget_view as BudgetViewJson | null | undefined;
  if (bv?.rag) return bv.rag || null;
  const tb = r.stats?.budget as TurnBudgetJson | null | undefined;
  if (tb?.rag) return tb.rag || null;
  return null;
}

export function getWebTelemetry(r?: RunJson | null): WebTelemetry | null {
  if (!r) return null;
  const bv = r.budget_view as BudgetViewJson | null | undefined;
  if (bv?.web) return bv.web || null;
  const tb = r.stats?.budget as TurnBudgetJson | null | undefined;
  if (tb?.web) return tb.web || null;
  return null;
}

export function getPackTelemetry(r?: RunJson | null): PackTelemetry | null {
  if (!r) return null;
  const bv = r.budget_view as BudgetViewJson | null | undefined;
  if (bv?.pack) return bv.pack || null;
  const tb = r.stats?.budget as TurnBudgetJson | null | undefined;
  if (tb?.pack) return tb.pack || null;
  return null;
}

export function getBudgetBreakdown(r?: RunJson | null): BudgetBreakdown | null {
  if (!r) return null;
  const bv = r.budget_view as BudgetViewJson | null | undefined;
  if (bv?.breakdown) return bv.breakdown || null;
  const tb = (r.stats?.budget as any) || null;
  if (tb?.breakdown) return (tb.breakdown as BudgetBreakdown) || null;
  return null;
}

export function getTimingMetrics(r?: RunJson | null): {
  ttftSec: number | null;
  totalSec: number | null;
  genSec: number | null;
  queueWaitSec: number | null;
  preModelSec: number | null;
  modelQueueSec: number | null;
  engine?: {
    loadSec?: number | null;
    promptSec?: number | null;
    evalSec?: number | null;
    promptN?: number | null;
    evalN?: number | null;
  } | null;
} | null {
  if (!r?.stats) return null;
  const timings: any = (r.stats as any).timings || null;
  const ttftSec =
    typeof timings?.ttftSec === "number"
      ? timings.ttftSec
      : typeof r.stats.timeToFirstTokenSec === "number"
        ? r.stats.timeToFirstTokenSec
        : null;
  const totalSec =
    typeof timings?.totalSec === "number"
      ? timings.totalSec
      : typeof r.stats.totalTimeSec === "number"
        ? r.stats.totalTimeSec
        : null;
  const genSec = typeof timings?.genSec === "number" ? timings.genSec : null;

  const qvFromBV = (r.budget_view as any)?.queueWaitSec;
  const qvFromStats = (r.stats as any)?.budget?.queueWaitSec;
  const queueWaitSec =
    typeof qvFromBV === "number"
      ? qvFromBV
      : typeof qvFromStats === "number"
        ? qvFromStats
        : typeof timings?.queueWaitSec === "number"
          ? timings.queueWaitSec
          : null;

  const preModelSec =
    typeof timings?.preModelSec === "number" ? timings.preModelSec : null;
  const modelQueueSec =
    typeof timings?.modelQueueSec === "number" ? timings.modelQueueSec : null;
  const engine = timings?.engine ?? null;
  return {
    ttftSec,
    totalSec,
    genSec,
    queueWaitSec,
    preModelSec,
    modelQueueSec,
    engine,
  };
}

export function getThroughput(r?: RunJson | null): {
  encodeTps: number | null;
  decodeTps: number | null;
  overallTps: number | null;
  promptN: number | null;
  evalN: number | null;
} | null {
  if (!r?.stats) return null;
  const promptN =
    typeof r.stats.promptTokensCount === "number"
      ? r.stats.promptTokensCount
      : typeof r.stats.timings?.engine?.promptN === "number"
        ? r.stats.timings!.engine!.promptN!
        : null;
  const evalN =
    typeof r.stats.predictedTokensCount === "number"
      ? r.stats.predictedTokensCount
      : typeof r.stats.timings?.engine?.evalN === "number"
        ? r.stats.timings!.engine!.evalN!
        : null;
  const modelQueueSec =
    typeof r.stats.timings?.modelQueueSec === "number"
      ? r.stats.timings!.modelQueueSec!
      : null;
  const genSec =
    typeof r.stats.timings?.genSec === "number"
      ? r.stats.timings!.genSec!
      : null;
  const totalTokens =
    typeof r.stats.totalTokensCount === "number"
      ? r.stats.totalTokensCount
      : null;
  const totalSec =
    typeof r.stats.totalTimeSec === "number"
      ? r.stats.totalTimeSec
      : typeof r.stats.timings?.totalSec === "number"
        ? r.stats.timings!.totalSec!
        : null;
  const safeDiv = (n: number | null, d: number | null) =>
    n != null && d != null && d > 0 ? n / d : null;
  const encodeTps = safeDiv(promptN, modelQueueSec);
  const decodeTps = safeDiv(evalN, genSec);
  const overallTps = safeDiv(totalTokens, totalSec);
  return { encodeTps, decodeTps, overallTps, promptN, evalN };
}

# ===== frontend/src/shared/lib/runjson.ts =====

// frontend/src/file_read/components/shared/lib/runjson.ts
export * from "./runjson.types";
export * from "./runjson.helpers";

# ===== frontend/src/shared/lib/runjson.types.ts =====

// frontend/src/file_read/components/shared/lib/runjson.types.ts
export const MET_START = "[[RUNJSON]]";
export const MET_END = "[[/RUNJSON]]";

export type GenMetrics = {
  ttft_ms?: number | null;
  tok_per_sec?: number | null;
  output_tokens?: number | null;
  input_tokens_est?: number | null;
  total_tokens_est?: number | null;
  stop_reason?: string | null;
};

export type RagTelemetry = {
  routerDecideSec?: number;
  routerNeeded?: boolean;
  routerQuery?: string;
  embedSec?: number;
  searchChatSec?: number;
  searchGlobalSec?: number;
  hitsChat?: number;
  hitsGlobal?: number;
  dedupeSec?: number;
  blockBuildSec?: number;
  injectBuildSec?: number;
  sessionOnlyBuildSec?: number;
  topKRequested?: number;
  blockChars?: number;
  injected?: boolean;
  mode?: string;
  blockTokens?: number;
  blockTokensApprox?: number;
  packedTokensBefore?: number;
  packedTokensAfter?: number;
  ragTokensAdded?: number;
  sessionOnlyTokensApprox?: number;
  sessionOnly?: boolean;
  routerSkipped?: boolean;
  routerSkippedReason?: string;
};

export type WebBreakdown = {
  routerSec?: number;
  summarizeSec?: number;
  searchSec?: number;
  fetchSec?: number;
  jsFetchSec?: number;
  assembleSec?: number;
  orchestratorSec?: number;
  injectSec?: number;
  totalWebPreTtftSec?: number;
  unattributedWebSec?: number;
  prepSec?: number;
};

export type WebTelemetry = {
  needed?: boolean;
  summarizedQuery?: string;
  fetchElapsedSec?: number;
  blockChars?: number;
  injectElapsedSec?: number;
  ephemeralBlocks?: number;
  summarizer?: Record<string, unknown> | null;
  orchestrator?: Record<string, unknown> | null;
  elapsedSec?: number;
  breakdown?: WebBreakdown | null;
};

export type PackTelemetry = {
  packSec?: number;
  summarySec?: number;
  finalTrimSec?: number;
  compressSec?: number;
  summaryTokensApprox?: number;
  summaryUsedLLM?: boolean;
  packedChars?: number;
  messages?: number;

  packInputTokensApprox?: number;
  packMsgs?: number;

  finalTrimTokensBefore?: number;
  finalTrimTokensAfter?: number;
  finalTrimDroppedMsgs?: number;
  finalTrimDroppedApproxTokens?: number;
  finalTrimSummaryShrunkFromChars?: number;
  finalTrimSummaryShrunkToChars?: number;
  finalTrimSummaryDroppedChars?: number;

  rollStartTokens?: number;
  rollOverageTokens?: number;
  rollPeeledMsgs?: number;
  rollNewSummaryChars?: number;
  rollNewSummaryTokensApprox?: number;
};

export type TurnBudgetJson = {
  n_ctx?: number;
  input_tokens_est?: number | null;
  requested_out_tokens?: number;
  clamped_out_tokens?: number;
  clamp_margin?: number;
  reserved_system_tokens?: number | null;
  available_for_out_tokens?: number | null;
  headroom_tokens?: number | null;
  overage_tokens?: number | null;
  reason?: string;
  rag?: RagTelemetry | null;
  web?: WebTelemetry | null;
  pack?: PackTelemetry | null;
  ephemeral?: boolean;
  droppedFromSummary?: boolean;
};

export type BudgetView = {
  modelCtx: number;
  clampMargin: number;
  usableCtx: number;
  inputTokensEst: number;
  outBudgetChosen: number;
  outBudgetDefault: number;
  outBudgetRequested: number;
  outBudgetMaxAllowed: number;
  overByTokens: number;
  minOutTokens: number;
  queueWaitSec: number | null;
};

export type BudgetBreakdown = {
  ttftSec?: number;
  preTtftAccountedSec?: number;
  unattributedTtftSec?: number;
};

export type BudgetViewJson = Partial<BudgetView> & {
  rag?: RagTelemetry | null;
  web?: WebTelemetry | null;
  pack?: PackTelemetry | null;
  breakdown?: BudgetBreakdown | null;
};

export type RunJson = {
  stats?: {
    stopReason?: string | null;
    tokensPerSecond?: number | null;
    timeToFirstTokenSec?: number | null;
    totalTimeSec?: number | null;
    promptTokensCount?: number | null;
    predictedTokensCount?: number | null;
    totalTokensCount?: number | null;
    budget?: TurnBudgetJson | null;
    timings?: {
      queueWaitSec?: number | null;
      genSec?: number | null;
      ttftSec?: number | null;
      totalSec?: number | null;
      preModelSec?: number | null;
      modelQueueSec?: number | null;
      engine?: {
        loadSec?: number | null;
        promptSec?: number | null;
        evalSec?: number | null;
        promptN?: number | null;
        evalN?: number | null;
      } | null;
    } | null;
  };
  budget_view?: BudgetViewJson | null;
  [k: string]: unknown;
};

export type NormalizedBudget = {
  modelCtx: number;
  clampMargin: number;
  inputTokensEst: number;
  outBudgetChosen: number;
  outBudgetMaxAllowed: number;
  overByTokens: number;
};

# ===== frontend/src/shared/lib/text.ts =====

export function firstLineSmart(s: string, max = 48): string {
  const one = s.replace(/\s+/g, " ").trim();
  return one.length <= max ? one : one.slice(0, max - 1).trimEnd() + "â€¦";
}

# ===== frontend/src/shared/ui/CodeCopyButton.tsx =====

// frontend/src/file_read/components/CodeCopyButton.tsx
import { Copy, Check } from "lucide-react";
import { useState } from "react";

export default function CodeCopyButton({ text }: { text: string }) {
  const [copied, setCopied] = useState(false);
  async function onCopy() {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);
      setTimeout(() => setCopied(false), 1500);
    } catch {}
  }
  return (
    <button
      type="button"
      onClick={onCopy}
      title={copied ? "Copied!" : "Copy"}
      className="inline-flex items-center justify-center w-7 h-7 rounded bg-gray-200 text-gray-600 hover:bg-gray-300 transition"
    >
      {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
    </button>
  );
}

# ===== frontend/src/shared/ui/Toast.tsx =====

export default function Toast({ message }: { message: string | null }) {
  if (!message) return null;
  return (
    <div className="pointer-events-none fixed bottom-4 left-1/2 -translate-x-1/2 z-50">
      <div className="px-3 py-2 rounded-lg bg-black text-white text-xs shadow-lg">
        {message}
      </div>
    </div>
  );
}

# ===== frontend/src/shared/ui/TypingIndicator.tsx =====

// components/TypingIndicator.tsx
export default function TypingIndicator() {
  return (
    <div className="flex items-start gap-2">
      {/* Optional avatar spot */}
      <div className="h-8 w-8 rounded-full bg-gray-200 shrink-0" />
      <div className="px-3 py-2 rounded-lg bg-gray-100 text-gray-600">
        <span className="inline-flex gap-1">
          <span className="h-2 w-2 rounded-full bg-gray-400 animate-bounce [animation-delay:-0.2s]" />
          <span className="h-2 w-2 rounded-full bg-gray-400 animate-bounce [animation-delay:-0.1s]" />
          <span className="h-2 w-2 rounded-full bg-gray-400 animate-bounce" />
        </span>
      </div>
    </div>
  );
}

# ===== frontend/src/types/chat.ts =====

export type Role = "user" | "assistant";

import type { GenMetrics, RunJson } from "../shared/lib/runjson";

export type Attachment = {
  name: string;
  source?: string;
  sessionId?: string | null;
};

export type ChatMsg = {
  id: string; // clientId
  serverId: number | null;
  role: Role;
  text: string;
  attachments?: Attachment[];
  meta?: {
    runJson?: RunJson | null;
    flat?: GenMetrics | null;
  };
};

export type ChatRow = {
  id: number;
  sessionId: string;
  title: string;
  lastMessage: string | null;
  createdAt: string;
  updatedAt: string;
  /** present on admin endpoints */
  ownerUid?: string;
  ownerEmail?: string | null;
};

export type ChatMessageRow = {
  id: number;
  sessionId: string;
  role: Role;
  content: string;
  createdAt: string;
  attachments?: Attachment[]; // âœ… this must exist
};

# ===== frontend/src/vite-env.d.ts =====

/// <reference types="vite/client" />
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_STRIPE_PRICE_PRO_MONTHLY?: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
