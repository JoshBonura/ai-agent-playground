n>
          </div>
        </div>
      )}

      {open && (
        <div className="md:hidden">
          <div className="fixed inset-0 z-40 bg-black/30" onClick={() => setOpen(false)} />
          <div className="fixed inset-x-0 bottom-0 z-50 rounded-t-2xl bg-white shadow-2xl">
            <div className="px-4 pt-4 pb-2 text-sm text-gray-600 truncate border-b">{display}</div>

            {/* License Key (mobile) */}
            <div className="p-4 border-b bg-gray-50/60">
              <div className="text-[11px] font-medium text-gray-600 mb-1">License key</div>
              <div className="flex items-center gap-2">
                <input
                  value={license}
                  onChange={(e) => setLicense(e.target.value)}
                  placeholder="paste-your-key"
                  className="flex-1 rounded-lg border px-3 py-2 text-sm outline-none focus:ring-2 focus:ring-black"
                  spellCheck={false}
                />
                <button
                  onClick={saveLicense}
                  className="inline-flex items-center gap-1 rounded-lg border px-3 py-2 text-sm hover:bg-gray-50"
                >
                  <Save size={16} /> Save
                </button>
              </div>
              {saved === "ok" && <div className="mt-1 text-[11px] text-green-600">Saved</div>}
              {saved === "err" && <div className="mt-1 text-[11px] text-red-600">Couldn’t save</div>}
            </div>

            <div className="p-2">
              <button className="w-full flex items-center gap-2 px-3 py-3 rounded-lg hover:bg-gray-50" onClick={() => { setOpen(false); }}>
                <Stars className="w-4 h-4" /> Upgrade plan
              </button>
              <button className="w-full flex items-center gap-2 px-3 py-3 rounded-lg hover:bg-gray-50" onClick={openCustomize}>
                <Wand2 className="w-4 h-4" /> Customize
              </button>
              <button className="w-full flex items-center gap-2 px-3 py-3 rounded-lg hover:bg-gray-50" onClick={openKnowledge}>
                <BookOpen className="w-4 h-4" /> Knowledge
              </button>
              <button className="w-full flex items-center gap-2 px-3 py-3 rounded-lg hover:bg-gray-50" onClick={openSettings}>
                <Settings className="w-4 h-4" /> Settings
              </button>
              <button className="w-full flex items-center gap-2 px-3 py-3 rounded-lg hover:bg-gray-50 text-red-600" onClick={logout}>
                <LogOut className="w-4 h-4" /> Log out
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatSidebar/ChatSidebar.tsx =====

import { useState } from "react";
import { deleteChatsBatch } from "../../data/chatApi";
import type { ChatRow } from "../../types/chat";
import { useMultiSelect } from "../../hooks/useMultiSelect";
import { useChatsPager } from "../../hooks/useChatsPager";
import SidebarHeader from "./SidebarHeader";
import SidebarListItem from "./SidebarListItem";
import AccountPanel from "./AccountPanel";

const PAGE_SIZE = 10;

type Props = {
  onOpen: (id: string) => Promise<void>;
  onNew: () => Promise<void>;
  refreshKey?: number;
  activeId?: string;
  onHideSidebar?: () => void;
  onCancelSessions?: (ids: string[]) => Promise<void>;
};

export default function ChatSidebar({
  onOpen, onNew, refreshKey, activeId, onHideSidebar, onCancelSessions,
}: Props) {
  const {
    chats, page, hasMore, total, totalPages,
    initialLoading, loadingMore,
    scrollRef, sentinelRef, loadMore, setChats, decTotal,
  } = useChatsPager(PAGE_SIZE, refreshKey);

  const [isEditing, setIsEditing] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [newPending, setNewPending] = useState(false);

  const allIds = chats.map(c => c.sessionId);
  const { selected, setSelected, allSelected, toggleOne, toggleAll } = useMultiSelect(allIds);

  async function handleNew() {
    if (newPending) return;
    setNewPending(true);
    try { await onNew(); } finally { setNewPending(false); }
  }

  async function onDeleteSelected(): Promise<void> {
    const count = selected.size;
    if (!count || deleting) return;

    const isAll = count === chats.length;
    const ok = window.confirm(
      isAll
        ? `Delete ALL ${count} chats? This cannot be undone.`
        : `Delete ${count} selected chat${count > 1 ? "s" : ""}?`
    );
    if (!ok) return;

    const ids = [...selected];
    try { await onCancelSessions?.(ids); await Promise.resolve(); } catch {}

    const deletingActive = activeId ? selected.has(activeId) : false;
    const fallback = chats.find(c => !selected.has(c.sessionId))?.sessionId;

    setDeleting(true);
    try {
      const deleted = await deleteChatsBatch(ids);
      if (!deleted.length) return;
      setChats(prev => prev.filter(c => !deleted.includes(c.sessionId)));
      decTotal(deleted.length);
      setSelected(new Set());
      setIsEditing(false);

      if (deletingActive && fallback) {
        void onOpen(fallback);
      }
    } finally {
      setDeleting(false);
    }
  }

  return (
    <aside className="w-full md:w-72 h-full border-r bg-white p-0 flex flex-col">
      <SidebarHeader
        isEditing={isEditing}
        setIsEditing={(v) => { setIsEditing(v); setSelected(new Set()); }}
        newPending={newPending}
        onNew={handleNew}
        onHideSidebar={onHideSidebar}
        selectedCount={selected.size}
        deleting={deleting}
        onDelete={onDeleteSelected}
      />

      <div
        ref={scrollRef}
        className="flex-1 overflow-y-auto p-2 overscroll-contain"
        style={{ WebkitOverflowScrolling: "touch" }}
      >
        {initialLoading && (
          <div className="px-2 py-1 text-xs text-gray-500">Loading…</div>
        )}

        <ul className="space-y-1">
          {chats.map((c: ChatRow) => (
            <SidebarListItem
              key={c.sessionId}
              c={c}
              isActive={activeId === c.sessionId}
              isEditing={isEditing}
              isChecked={selected.has(c.sessionId)}
              onToggle={() => toggleOne(c.sessionId)}
              onOpen={() => void onOpen(c.sessionId)}
            />
          ))}
        </ul>

        <div className="h-6" ref={sentinelRef} />

        {hasMore && (
          <div className="px-2 pb-2">
            <button
              className={`w-full text-xs px-3 py-1 rounded border ${loadingMore ? "opacity-50 cursor-wait" : ""}`}
              onClick={() => void loadMore()}
              disabled={loadingMore}
              title="Load next page"
            >
              {loadingMore ? "Loading…" : `Load more (${chats.length}/${total || "?"})`}
            </button>
          </div>
        )}

        {!hasMore && chats.length > 0 && (
          <div className="px-2 py-2 text-[11px] text-gray-400 text-center">
            End of list • showing {chats.length} of {total || chats.length}
          </div>
        )}
      </div>

      <div className="border-t px-3 py-2 text-[11px] text-gray-500">
        <span className="uppercase tracking-wide">Chats</span>{" "}
        <span className="text-gray-400">
          ({chats.length}{total ? `/${total}` : ""} • page {Math.max(page, 1)} of {Math.max(totalPages || 1, 1)})
        </span>
        {isEditing && (
          <label className="ml-2 text-[11px]">
            <input
              type="checkbox"
              className="mr-1 align-middle"
              checked={allSelected}
              onChange={toggleAll}
            />
            Select all
          </label>
        )}
      </div>

      <div className="border-t">
        <AccountPanel />
      </div>
    </aside>
  );
}

# ===== frontend/src/file_read/components/ChatSidebar/SidebarHeader.tsx =====

import { PanelLeftClose, Plus, Pencil, Trash2 } from "lucide-react";

export default function SidebarHeader({
  isEditing, setIsEditing, newPending, onNew, onHideSidebar,
  selectedCount, deleting, onDelete,
}: {
  isEditing: boolean;
  setIsEditing: (v: boolean) => void;
  newPending: boolean;
  onNew: () => Promise<void>;
  onHideSidebar?: () => void;
  selectedCount: number;
  deleting: boolean;
  onDelete: () => void;
}) {
  return (
    <div className="sticky top-0 z-10 bg-white border-b">
      <div className="flex items-center justify-between px-3 py-2">
        <div className="text-[11px] md:text-xs uppercase text-gray-500">Chats</div>
        <div className="flex items-center gap-2">
          <button
            className={`h-9 px-3 inline-flex items-center gap-2 justify-center rounded border ${
              newPending ? "opacity-50 cursor-not-allowed" : ""
            }`}
            onClick={async () => { if (!newPending) await onNew(); }}
            title="New chat"
            disabled={newPending}
          >
            <Plus className="w-4 h-4" />
            <span className="text-xs md:text-[11px] leading-none">New</span>
          </button>

          <button
            className="h-9 px-3 inline-flex items-center gap-2 justify-center rounded border"
            onClick={() => setIsEditing(!isEditing)}
            aria-pressed={isEditing}
            title={isEditing ? "Exit edit mode" : "Edit chats"}
          >
            <Pencil className="w-4 h-4" />
            <span className="text-xs md:text-[11px] leading-none">
              {isEditing ? "Done" : "Edit"}
            </span>
          </button>

          {onHideSidebar && (
            <button
              className="hidden md:inline-flex h-9 w-9 items-center justify-center rounded border"
              onClick={onHideSidebar}
              title="Hide sidebar"
              aria-label="Hide sidebar"
            >
              <PanelLeftClose className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>

      {isEditing && (
        <div className="px-3 py-2 border-t bg-white flex items-center gap-3">
          <div className="text-sm text-gray-600">{selectedCount} selected</div>
          <button
            className={`ml-auto inline-flex items-center gap-2 text-sm px-3 py-1 rounded ${
              selectedCount && !deleting
                ? "bg-red-600 text-white"
                : "bg-gray-200 text-gray-500 cursor-not-allowed"
            }`}
            disabled={!selectedCount || deleting}
            onClick={onDelete}
            title={selectedCount ? "Delete selected chats" : "Select chats to delete"}
          >
            <Trash2 className="w-4 h-4" />
            {deleting ? "Deleting…" : `Delete (${selectedCount})`}
          </button>
        </div>
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatSidebar/SidebarListItem.tsx =====

import { firstLineSmart } from "../../shared/lib/text";
import type { ChatRow } from "../../types/chat";

export default function SidebarListItem({
  c, isActive, isEditing, isChecked, onToggle, onOpen,
}: {
  c: ChatRow;
  isActive: boolean;
  isEditing: boolean;
  isChecked: boolean;
  onToggle: () => void;
  onOpen: () => void;
}) {
  const displayTitle =
    (c.title && c.title.trim()) ||
    firstLineSmart(c.lastMessage || "", 48) ||
    "New Chat";
  const preview = c.lastMessage ? firstLineSmart(c.lastMessage, 120) : "";

  return (
    <li>
      <div
        className={`w-full flex items-start gap-2 px-2 py-2 rounded ${
          isActive ? "bg-black text-white" : "hover:bg-gray-50"
        }`}
      >
        {isEditing && (
          <input
            type="checkbox"
            checked={isChecked}
            onChange={onToggle}
            className="mt-1"
            aria-label={`Select chat ${displayTitle}`}
          />
        )}
        <button
          className="text-left flex-1"
          aria-current={isActive ? "true" : undefined}
          onClick={() => { if (!isEditing) onOpen(); }}
          title={displayTitle}
        >
          <div className="font-medium truncate">{displayTitle}</div>
          {preview && (
            <div className={`text-xs line-clamp-2 ${isActive ? "text-white/80" : "text-gray-500"}`}>
              {preview}
            </div>
          )}
          <div className="text-[10px] mt-1 opacity-60">
            {new Date(c.updatedAt).toLocaleString()}
          </div>
        </button>
      </div>
    </li>
  );
}

# ===== frontend/src/file_read/components/ChatView/ChatView.tsx =====

// frontend/src/file_read/components/ChatView/ChatView.tsx
import type { ChatMsg } from "../../types/chat";
import type { GenMetrics, RunJson } from "../../hooks/useChatStream";
import ChatItem from "../ChatItem";
import TypingIndicator from "../../shared/ui/TypingIndicator";
import { useChatAutofollow } from "../../hooks/useChatAutoFollow";

export default function ChatView({
  messages,
  loading,
  queued = false,
  bottomPad,
  runMetrics,
  runJson,
  onDeleteMessages,
  autoFollow = true,
}: {
  messages: ChatMsg[];
  loading: boolean;
  queued?: boolean;
  bottomPad: number;
  runMetrics?: GenMetrics | null;
  runJson?: RunJson | null;
  onDeleteMessages?: (ids: string[]) => void;
  autoFollow?: boolean;
}) {
  const { listRef, bottomRef, lastAssistantIndex } = useChatAutofollow({
    messages,
    loading,
    autoFollow,
    bottomPad,
  });

  const lastMsg = messages[messages.length - 1];

  return (
    <div
      ref={listRef}
      className="p-4 space-y-3 bg-gray-50 min-w-0"
      style={{ paddingBottom: bottomPad }}
    >
      {messages.map((m, idx) => (
        <ChatItem
          key={m.id}
          m={m}
          idx={idx}
          loading={loading}
          lastAssistantIndex={lastAssistantIndex}
          runJsonLive={runJson ?? null}
          runMetricsLive={runMetrics ?? null}
          onDelete={onDeleteMessages ? (id) => onDeleteMessages([id]) : undefined}
        />
      ))}

      {(loading || queued) &&
        !(lastMsg?.role === "assistant" && (lastMsg.text?.trim().length ?? 0) > 0) && (
          <TypingIndicator />
        )}

      <div ref={bottomRef} className="h-0" />
    </div>
  );
}

# ===== frontend/src/file_read/components/ChatView/StatusLine.ts =====

// frontend/src/file_read/components/chat/StatusLine.ts
import type { RunJson, GenMetrics } from "../../shared/lib/runjson";

const oneDec = (n?: number | null) =>
  typeof n === "number" && Number.isFinite(n) ? n.toFixed(1) : undefined;

export function buildStatus(json?: RunJson | null, flat?: GenMetrics | null) {
  const st = json?.stats;
  if (st) {
    const parts: string[] = [];
    if (st.predictedTokensCount != null) parts.push(`${st.predictedTokensCount} tok`);
    if (st.tokensPerSecond != null) parts.push(`${oneDec(st.tokensPerSecond) ?? st.tokensPerSecond} tok/s`);
    if (st.timeToFirstTokenSec != null) parts.push(`TTFT ${Math.round(st.timeToFirstTokenSec * 1000)} ms`);
    if (st.stopReason) parts.push(`stop: ${st.stopReason}`);
    return parts.join(" • ");
  }
  if (flat) {
    const parts: string[] = [];
    if (flat.output_tokens != null) parts.push(`${flat.output_tokens} tok`);
    if (flat.tok_per_sec != null) parts.push(`${oneDec(flat.tok_per_sec) ?? flat.tok_per_sec} tok/s`);
    if (flat.ttft_ms != null) parts.push(`TTFT ${Math.round(flat.ttft_ms)} ms`);
    if (flat.stop_reason) parts.push(`stop: ${flat.stop_reason}`);
    return parts.join(" • ");
  }
  return "";
}

# ===== frontend/src/file_read/components/Composer/AttachmentChip.tsx =====

import { X, Check } from "lucide-react";
import ProgressBar from "./ProgressBar";
import type { Att } from "../../hooks/useAttachmentUploads";

export default function AttachmentChip({
  a,
  onRemove,
}: {
  a: Att;
  onRemove: (a: Att) => void;
}) {
  return (
    <div className="min-w-[160px] max-w-[280px] border rounded-lg px-2 py-2">
      <div className="flex items-center justify-between gap-2">
        <div className="truncate text-sm" title={a.name}>
          {a.name}
        </div>
        <button
          className="p-1 rounded hover:bg-gray-100"
          aria-label="Remove file"
          onClick={() => onRemove(a)}
        >
          <X size={14} />
        </button>
      </div>
      <ProgressBar pct={a.pct} error={a.status === "error"} />
      <div className="mt-1 text-xs text-gray-500 flex items-center gap-1">
        {a.status === "uploading" && <span>Uploading… {a.pct}%</span>}
        {a.status === "ready" && (
          <>
            <Check size={14} /> Ready
          </>
        )}
        {a.status === "error" && <span>Error</span>}
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/Composer/ComposerActions.tsx =====

import { Paperclip, Square, SendHorizonal } from "lucide-react";

type Props = {
  disabledUpload: boolean;
  onPickFile: () => void;
  showStop: boolean;
  onStop: () => void;
  showSend: boolean;
  onSend: () => void;
};

export default function ComposerActions({
  disabledUpload,
  onPickFile,
  showStop,
  onStop,
  showSend,
  onSend,
}: Props) {
  return (
    <div className="flex items-end gap-2">
      <button
        className={`p-2 rounded-lg border hover:bg-gray-50 ${disabledUpload ? "opacity-60 cursor-not-allowed" : ""}`}
        onClick={onPickFile}
        title="Upload to this chat"
        aria-label="Upload to this chat"
        disabled={disabledUpload}
      >
        <Paperclip size={18} />
      </button>

      {showStop ? (
        <button
          className="p-2 rounded-lg border hover:bg-gray-50"
          onClick={onStop}
          title="Stop generating"
          aria-label="Stop generating"
        >
          <Square size={18} />
        </button>
      ) : showSend ? (
        <button
          className="p-2 rounded-lg bg-black text-white hover:bg-black/90 active:translate-y-px"
          onClick={onSend}
          title="Send"
          aria-label="Send"
        >
          <SendHorizonal size={18} />
        </button>
      ) : null}
    </div>
  );
}

# ===== frontend/src/file_read/components/Composer/ProgressBar.tsx =====

export default function ProgressBar({ pct, error }: { pct: number; error?: boolean }) {
  return (
    <div className="mt-2 h-1.5 w-full bg-gray-200 rounded">
      <div
        className={`h-1.5 rounded ${error ? "bg-red-500" : "bg-black"}`}
        style={{ width: `${pct}%` }}
      />
    </div>
  );
}

# ===== frontend/src/file_read/components/DesktopHeader.tsx =====

import { PanelLeftOpen } from "lucide-react";

export default function DesktopHeader({
  sidebarOpen,
  onShowSidebar,
  title = "Local AI Model",
}: {
  sidebarOpen: boolean;
  onShowSidebar: () => void;
  title?: string;
}) {
  return (
    <div className="hidden md:flex h-14 shrink-0 items-center justify-between px-4 border-b bg-white">
      <div className="flex items-center gap-2">
        {!sidebarOpen && (
          <button
            className="h-9 w-9 inline-flex items-center justify-center rounded-lg border hover:bg-gray-50"
            onClick={onShowSidebar}
            aria-label="Show sidebar"
            title="Show sidebar"
          >
            <PanelLeftOpen className="w-4 h-4" />
          </button>
        )}
        <div className="font-semibold">{title}</div>
      </div>
      <div />
    </div>
  );
}

# ===== frontend/src/file_read/components/KnowledgePanel.tsx =====

import { useState, useEffect } from "react";
import {
  uploadRag,
  searchRag,
  listUploads,
  deleteUploadHard,
  type UploadRow,
} from "../data/ragApi";

export default function KnowledgePanel({
  sessionId,
  onClose,
  toast,
}: {
  sessionId?: string;
  onClose?: () => void;
  toast?: (msg: string) => void;
}) {
  const [files, setFiles] = useState<FileList | null>(null);
  const [busy, setBusy] = useState(false);
  const [query, setQuery] = useState("");
  const [hits, setHits] = useState<{ text: string; source?: string; score: number }[]>([]);
  const [searching, setSearching] = useState(false);

  const [scope, setScope] = useState<"all" | "session">("all");
  const [uploads, setUploads] = useState<UploadRow[]>([]);
  const [loadingUploads, setLoadingUploads] = useState(false);

  useEffect(() => {
    void refreshUploads();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [scope, sessionId]);

  async function refreshUploads() {
    setLoadingUploads(true);
    try {
      const out = await listUploads(sessionId, scope);
      setUploads(out.uploads || []);
    } catch (e: any) {
      toast?.(e?.message || "Failed to load uploads");
    } finally {
      setLoadingUploads(false);
    }
  }

  async function handleDeleteHard(source: string, ns?: string | null) {
    try {
      const res = await deleteUploadHard(source, ns ?? undefined);
      toast?.(`Removed ${res.removed} chunk${res.removed === 1 ? "" : "s"}. Remaining: ${res.remaining}`);
      await refreshUploads();
    } catch (e: any) {
      toast?.(e?.message || "Delete failed");
    }
  }

  async function doUpload() {
    if (!files || !files.length) return;
    setBusy(true);
    try {
      let total = 0;
      for (const f of Array.from(files)) {
        const out = await uploadRag(f, undefined);
        total += (out as any)?.added || 0;
      }
      toast?.(`Added ${total} chunk${total === 1 ? "" : "s"}`);
      setFiles(null);
      await refreshUploads();
    } catch (e: any) {
      toast?.(e?.message || "Upload failed");
    } finally {
      setBusy(false);
    }
  }

  async function doSearch() {
    const q = query.trim();
    if (!q) return;
    setSearching(true);
    try {
      const out = await searchRag(q, { sessionId, kChat: 6, kGlobal: 4, alpha: 0.5 });
      setHits(out.hits || []);
    } catch (e: any) {
      toast?.(e?.message || "Search failed");
    } finally {
      setSearching(false);
    }
  }

  return (
    <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center p-3">
      <div className="w-full max-w-5xl rounded-2xl bg-white shadow-xl border overflow-hidden">
        <div className="px-4 py-3 border-b flex items-center gap-2">
          <div className="font-semibold">Knowledge</div>
          <div className="ml-auto flex items-center gap-2">
            <button className="text-xs px-3 py-1.5 rounded border hover:bg-gray-50" onClick={onClose}>
              Close
            </button>
          </div>
        </div>

        <div className="p-4 grid gap-6 md:grid-cols-2">
          {/* Upload */}
          <div>
            <div className="font-medium mb-2">Upload documents</div>
            <input type="file" multiple className="block w-full text-sm" onChange={(e) => setFiles(e.target.files)} />
            <button
              className={`mt-2 text-sm px-3 py-1.5 rounded ${busy ? "opacity-60 cursor-not-allowed" : "bg-black text-white"}`}
              disabled={busy || !files || files.length === 0}
              onClick={doUpload}
            >
              {busy ? "Uploading…" : "Upload"}
            </button>
            <div className="text-[11px] text-gray-500 mt-2">
              Tip: CSV, TXT, MD, PDF (text extracted). Uploads can be global or per chat.
            </div>

            <div className="mt-6">
              <div className="flex items-center gap-2 mb-2">
                <div className="font-medium">Your uploads</div>
                <select
                  className="ml-auto border rounded px-2 py-1 text-xs"
                  value={scope}
                  onChange={(e) => setScope(e.target.value as "all" | "session")}
                  title="Scope"
                >
                  <option value="all">All (global + this chat)</option>
                  <option value="session">This chat only</option>
                </select>
                <button
                  className="text-xs px-2 py-1 rounded border hover:bg-gray-50"
                  onClick={refreshUploads}
                  disabled={loadingUploads}
                >
                  {loadingUploads ? "Refreshing…" : "Refresh"}
                </button>
              </div>

              <ul className="space-y-2 max-h-64 overflow-auto">
                {uploads.length === 0 && (
                  <li className="text-xs text-gray-500">No uploads yet.</li>
                )}
                {uploads.map((u, i) => (
                  <li key={`${u.source}-${u.sessionId ?? "global"}-${i}`} className="p-2 border rounded bg-gray-50">
                    <div className="flex items-center gap-2">
                      <div className="font-mono text-xs break-all">{u.source}</div>
                      <span className="text-[11px] text-gray-500">
                        {u.sessionId ? "session" : "global"} • {u.chunks} chunk{u.chunks === 1 ? "" : "s"}
                      </span>
                      <button
                        className="ml-auto text-xs px-2 py-1 rounded border hover:bg-gray-100"
                        title="Delete (hard delete by Source)"
                        onClick={() => handleDeleteHard(u.source, u.sessionId ?? undefined)}
                      >
                        Delete
                      </button>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          </div>

          {/* Search */}
          <div>
            <div className="font-medium mb-2">Quick search</div>
            <div className="flex gap-2">
              <input
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Find in your knowledge…"
                className="flex-1 border rounded px-2 py-1.5 text-sm"
              />
              <button
                className={`text-sm px-3 py-1.5 rounded ${searching ? "opacity-60 cursor-wait" : "border hover:bg-gray-50"}`}
                onClick={doSearch}
                disabled={searching}
              >
                {searching ? "Searching…" : "Search"}
              </button>
            </div>

            <ul className="mt-3 space-y-2 max-h-64 overflow-auto">
              {hits.map((h, i) => (
                <li key={i} className="p-2 border rounded bg-gray-50">
                  <div className="text-[11px] text-gray-500 mb-1">
                    {h.source || "uploaded"} • score {Number.isFinite(h.score) ? h.score.toFixed(3) : "—"}
                  </div>
                  <div className="text-sm whitespace-pre-wrap">{h.text}</div>
                </li>
              ))}
              {!hits.length && <li className="text-xs text-gray-500">No results yet.</li>}
            </ul>
          </div>
        </div>

        <div className="px-4 py-3 border-t text-[11px] text-gray-500">
          “Delete” performs a hard delete: removes chunks for that Source and rebuilds the index.
        </div>
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/Markdown/MarkdownMessage.tsx =====

// frontend/src/file_read/components/MarkdownMessage.tsx
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import rehypeHighlight from "rehype-highlight";
import "highlight.js/styles/github.css";
import CodeCopyButton from "../../shared/ui/CodeCopyButton";

type Props = { text: string };

export default function MarkdownMessage({ text }: Props) {
  return (
    <>
      {/* keep pre spacing at zero; don't overwrite token colors */}
      <style>{`
        pre { margin: 0 !important; padding: 0 !important; background: transparent !important; }
        pre code { display: block; margin: 0 !important; padding: 0 !important; }
        .hljs { background: transparent !important; }
      `}</style>

      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        rehypePlugins={[[rehypeHighlight, { detect: true, ignoreMissing: true }]]}
        components={{
          code({
            inline,
            className,
            children,
            ...props
          }: {
            inline?: boolean;
            className?: string;
            children?: React.ReactNode;
          }) {
            const raw = String(children ?? "");
            const lang = (className || "").replace("language-", "");

            if (inline) {
              return (
                <code
                  className="px-1.5 py-0.5 rounded bg-gray-100 text-gray-900 font-mono text-[14px]"
                  {...props}
                >
                  {children}
                </code>
              );
            }

            return (
              <div className="relative w-full">
                <pre className="m-0 p-0 w-full overflow-x-auto rounded-md border border-gray-300">
                  {/* Let hljs theme color tokens; no text color override here */}
                  <code className={`${className ?? ""} hljs font-mono text-sm`} {...props}>
                    {children}
                  </code>
                </pre>

                <div className="absolute top-2 right-2 flex items-center gap-1">
                  {lang && (
                    <span className="text-[11px] px-1.5 py-0.5 rounded bg-gray-200 text-gray-700">
                      {lang}
                    </span>
                  )}
                  <CodeCopyButton text={raw} />
                </div>
              </div>
            );
          },
        }}
      >
        {text}
      </ReactMarkdown>
    </>
  );
}

# ===== frontend/src/file_read/components/MetricsHoverCard.tsx =====

// frontend/src/file_read/components/MetricsHoverCard.tsx
import { useEffect, useLayoutEffect, useRef, useState } from "react";
import { Info } from "lucide-react";
import MetricsHoverCardPanel from "./MetricsHoverCardPanel";

type Props = {
  data: unknown;
  title?: string;
  align?: "left" | "right";
  maxWidthPx?: number;
  compact?: boolean;
};

export default function MetricsHoverCard({
  data,
  title = "Run details",
  align = "right",
  maxWidthPx = 460,
  compact = true,
}: Props) {
  const [open, setOpen] = useState(false);
  const btnRef = useRef<HTMLButtonElement>(null);
  const panelRef = useRef<HTMLDivElement>(null);
  const [panelStyle, setPanelStyle] = useState<{ top: number; left: number; width: number } | null>(null);

  useLayoutEffect(() => {
    function place() {
      if (!open || !btnRef.current) return;
      const margin = 8;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const width = Math.min(maxWidthPx, vw - margin * 2);
      const btnBox = btnRef.current.getBoundingClientRect();
      let left = align === "right" ? btnBox.right - width : btnBox.left;
      left = Math.max(margin, Math.min(left, vw - margin - width));
      let top = btnBox.bottom + margin;
      let panelH = panelRef.current?.offsetHeight || 0;
      if (!panelH) panelH = 360 + 44;
      if (top + panelH > vh - margin) top = Math.max(margin, btnBox.top - margin - panelH);
      setPanelStyle({ top, left, width });
    }
    place();
    if (!open) return;
    const onReflow = () => place();
    window.addEventListener("resize", onReflow);
    window.addEventListener("scroll", onReflow, true);
    return () => {
      window.removeEventListener("resize", onReflow);
      window.removeEventListener("scroll", onReflow, true);
    };
  }, [open, align, maxWidthPx]);

  useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        e.preventDefault();
        setOpen(false);
        btnRef.current?.focus();
      }
    };
    const onDown = (e: MouseEvent) => {
      const t = e.target as Node;
      if (panelRef.current?.contains(t)) return;
      if (btnRef.current?.contains(t)) return;
      setOpen(false);
    };
    window.addEventListener("keydown", onKey);
    document.addEventListener("mousedown", onDown);
    return () => {
      window.removeEventListener("keydown", onKey);
      document.removeEventListener("mousedown", onDown);
    };
  }, [open]);

  return (
    <div className="relative inline-block">
      <button
        ref={btnRef}
        type="button"
        className={`inline-flex items-center justify-center rounded border bg-white text-gray-700 shadow-sm hover:bg-gray-50 transition ${compact ? "h-7 w-7" : "h-8 w-8"}`}
        title="Show run JSON"
        aria-haspopup="dialog"
        aria-expanded={open ? "true" : "false"}
        onClick={() => setOpen((v) => !v)}
        onMouseEnter={() => setOpen(true)}
      >
        <Info className={compact ? "w-4 h-4" : "w-5 h-5"} />
      </button>
      {open && panelStyle && (
        <div
          ref={panelRef}
          role="dialog"
          aria-label={title}
          className="fixed z-50"
          style={{ top: panelStyle.top, left: panelStyle.left, width: panelStyle.width }}
          onMouseLeave={() => setOpen(false)}
        >
          <MetricsHoverCardPanel data={data} title={title} />
        </div>
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/MetricsHoverCardPanel.tsx =====

// frontend/src/file_read/components/MetricsHoverCardPanel.tsx
import { useMemo, useState } from "react";
import { Copy, Check, X } from "lucide-react";
import type { RunJson } from "../shared/lib/runjson";
import {
  getNormalizedBudget,
  getRagTelemetry,
  getWebTelemetry,
  getTimingMetrics,
  getPackTelemetry,
} from "../shared/lib/runjson";

type PanelProps = {
  data: unknown;
  title: string;
};

const num0 = (v: unknown) => (typeof v === "number" && Number.isFinite(v) ? v : 0);

export default function MetricsHoverCardPanel({ data, title }: PanelProps) {
  const [copied, setCopied] = useState(false);

  const json = useMemo(() => {
    try {
      const r = (data ?? null) as RunJson | null;
      if (!r || typeof r !== "object") return JSON.stringify(data, null, 2);

      const nb = getNormalizedBudget(r);
      const rag = getRagTelemetry(r) as any | null;
      const web = getWebTelemetry(r) as any | null;
      const pack = getPackTelemetry(r) as any | null;
      const timing = getTimingMetrics(r) as any | null;

      const modelCtx = nb ? num0(nb.modelCtx) : null;
      const clampMargin = nb ? num0(nb.clampMargin) : null;
      const inputTokensEst = nb ? num0(nb.inputTokensEst) : null;
      const outBudgetChosen = nb ? num0(nb.outBudgetChosen) : null;
      const outActual = num0((r as any)?.stats?.predictedTokensCount);
      const outShown = outActual || (outBudgetChosen ?? 0);

      const webRouteSec = web?.elapsedSec;
      const webFetchSec = web?.fetchElapsedSec;
      const webInjectSec = web?.injectElapsedSec;
      const webPre =
        num0(web?.breakdown?.totalWebPreTtftSec) ||
        (num0(webRouteSec) + num0(webFetchSec) + num0(webInjectSec));

      const ragDelta = Math.max(
        0,
        num0((rag as any)?.ragTokensAdded) ||
          num0((rag as any)?.blockTokens) ||
          num0((rag as any)?.blockTokensApprox) ||
          num0((rag as any)?.sessionOnlyTokensApprox)
      );
      const ragPctOfInput =
        inputTokensEst && inputTokensEst > 0 ? Math.round((ragDelta / inputTokensEst) * 100) : 0;

      const packPackSec = num0(pack?.packSec);
      const packSummarySec = num0(pack?.summarySec);
      const packFinalTrimSec = num0(pack?.finalTrimSec);
      const packCompressSec = num0(pack?.compressSec);

      const preModelSec = num0(timing?.preModelSec);
      const modelQueueSec = num0(timing?.modelQueueSec);
      const genSec = num0(timing?.genSec);
      const ttftSec = num0(timing?.ttftSec);

      const breakdown = (r as any)?.budget_view?.breakdown || (r as any)?.stats?.budget?.breakdown || null;

      const preAccountedFromBackend = breakdown?.preTtftAccountedSec;
      const accountedFallback =
        webPre +
        num0((rag as any)?.routerDecideSec) +
        num0((rag as any)?.injectBuildSec ?? (rag as any)?.blockBuildSec ?? (rag as any)?.sessionOnlyBuildSec) +
        packPackSec +
        packSummarySec +
        packFinalTrimSec +
        packCompressSec +
        preModelSec +
        modelQueueSec;

      const accounted = Number.isFinite(preAccountedFromBackend) ? preAccountedFromBackend : accountedFallback;

      const unattributed =
        breakdown && Number.isFinite(breakdown.unattributedTtftSec)
          ? breakdown.unattributedTtftSec
          : Math.max(0, ttftSec - accounted);

      const promptTok = num0((r as any)?.stats?.promptTokensCount) || (inputTokensEst ?? 0);
      const decodeTok = num0((r as any)?.stats?.predictedTokensCount);
      const encodeTps = modelQueueSec > 0 ? promptTok / modelQueueSec : null;
      const decodeTps = genSec > 0 ? decodeTok / genSec : null;

      const totalTok =
        typeof (r as any)?.stats?.totalTokensCount === "number"
          ? ((r as any).stats.totalTokensCount as number)
          : promptTok + decodeTok;
      const totalSecForOverall =
        typeof (r as any)?.stats?.totalTimeSec === "number"
          ? ((r as any).stats.totalTimeSec as number)
          : num0(timing?.totalSec);
      const overallTps = totalSecForOverall > 0 ? totalTok / totalSecForOverall : null;

      const usedCtx = (inputTokensEst ?? 0) + outShown + (clampMargin ?? 0);
      const ctxPct = modelCtx && modelCtx > 0 ? Math.max(0, Math.min(100, (usedCtx / modelCtx) * 100)) : null;

      const augmented = {
        ...r,
        _derived: {
          context: { modelCtx, clampMargin, inputTokensEst, outBudgetChosen, outActual, outShown, usedCtx, ctxPct },
          rag: { ragDelta, ragPctOfInput },
          web: { webPre },
          timing: {
            accountedPreTtftSec: accounted,
            unattributedPreTtftSec: unattributed,
            preModelSec,
            modelQueueSec,
            genSec,
            ttftSec,
          },
          throughput: { encodeTokPerSec: encodeTps, decodeTokPerSec: decodeTps, overallTokPerSec: overallTps },
        },
      };

      return JSON.stringify(augmented, null, 2);
    } catch {
      return String(data ?? "");
    }
  }, [data]);

  return (
    <div className="rounded-xl border bg-white shadow-xl overflow-hidden">
      <div className="px-3 py-2 border-b flex items-center justify-between bg-gray-50">
        <div className="text-xs font-semibold text-gray-700">{title}</div>
        <div className="flex items-center gap-1">
          <button
            className="inline-flex items-center justify-center h-7 w-7 rounded border bg-white text-gray-700 hover:bg-gray-50"
            onClick={() => {
              navigator.clipboard.writeText(json);
              setCopied(true);
              window.setTimeout(() => setCopied(false), 1500);
            }}
            title="Copy JSON"
          >
            {copied ? <Check className="w-4 h-4" /> : <Copy className="w-4 h-4" />}
          </button>
          <button
            className="inline-flex items-center justify-center h-7 w-7 rounded border bg-white text-gray-700 hover:bg-gray-50"
            onClick={() => {}}
            title="Close"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      </div>

      {/* JSON only; badges removed */}
      <div className="p-3">
        <pre className="m-0 p-0 text-xs leading-relaxed overflow-auto" style={{ maxHeight: 360 }}>
          <code>{json}</code>
        </pre>
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/MobileDrawer.tsx =====

import { useState } from "react";
import { PanelLeftOpen } from "lucide-react";
import ChatSidebar from "./ChatSidebar/ChatSidebar";

export default function MobileDrawer({ ...props }) {
  const {
    onOpenSession, onNewChat, refreshKey, activeId,
    openMobileDrawer, closeMobileDrawer,
  } = props;

  const [mounted, setMounted] = useState(false);

  return (
    <>
      {/* Mobile top bar */}
      <div className="md:hidden fixed top-0 left-0 right-0 z-40 bg-white border-b">
        <div className="h-14 flex items-center justify-between px-3">
          <button
            className="inline-flex items-center justify-center h-9 w-9 rounded-lg border hover:bg-gray-50"
            onClick={() => { setMounted(true); openMobileDrawer(); }}  // ⬅️ mount on open
            aria-label="Open sidebar"
            title="Open sidebar"
          >
            <PanelLeftOpen className="w-4 h-4" />
          </button>
          <div className="font-semibold">Local AI Model</div>
          <div className="w-9" />
        </div>
      </div>

      {/* Backdrop */}
      <div
        id="mobile-backdrop"
        className="md:hidden fixed inset-0 z-40 bg-black/40 hidden"
        onClick={() => { setMounted(false); closeMobileDrawer(); }}  // ⬅️ unmount on close
      />

      {/* Drawer */}
      <aside
        id="mobile-drawer"
        role="dialog"
        aria-modal="true"
        className="md:hidden fixed inset-y-0 left-0 z-50 w-80 max-w-[85vw] bg-white border-r shadow-xl hidden animate-[slideIn_.2s_ease-out]"
      >
        <div className="h-14 flex items-center justify-between px-3 border-b">
          <div className="font-medium">Chats</div>
          <button
            className="h-9 w-9 inline-flex items-center justify-center rounded-lg border hover:bg-gray-50"
            onClick={() => { setMounted(false); closeMobileDrawer(); }}  // ⬅️ unmount on close
            aria-label="Close sidebar"
          >
            <span className="rotate-45 text-xl leading-none">+</span>
          </button>
        </div>

        {mounted && (                                             // ⬅️ only mount when open
          <ChatSidebar
            onOpen={async (id) => { await onOpenSession(id); setMounted(false); closeMobileDrawer(); }}
            onNew={async () => { await onNewChat(); setMounted(false); closeMobileDrawer(); }}
            refreshKey={refreshKey}
            activeId={activeId}
          />
        )}
      </aside>

      <style>{`@keyframes slideIn{from{transform:translateX(-12px);opacity:.0}to{transform:translateX(0);opacity:1}}`}</style>
    </>
  );
}

# ===== frontend/src/file_read/components/SearchTester.tsx =====

import { useState } from "react";
import ChatContainer from "../components/ChatContainer";
import ChatSidebar from "../components/ChatSidebar/ChatSidebar";
import { useChatStream } from "../hooks/useChatStream";
import { useSidebar } from "../hooks/useSidebar";
import { useToast } from "../hooks/useToast";
import DesktopHeader from "../components/DesktopHeader";
import MobileDrawer from "../components/MobileDrawer";
import Toast from "../shared/ui/Toast";
import { createChat, deleteMessagesBatch } from "../data/chatApi";

// NEW: settings panel
import SettingsPanel from "../components/SettingsPanel";
import KnowledgePanel from "../components/KnowledgePanel";
import SearchTester from "../components/SearchTester";

const LS_KEY = "lastSessionId";

export default function AgentRunner() {
  const chat = useChatStream();
  const [showKnowledge, setShowKnowledge] = useState(false);
  const [refreshKey, setRefreshKey] = useState(0);
  const [autoFollow, setAutoFollow] = useState(true);
  const { toast, show } = useToast();
  const { sidebarOpen, setSidebarOpen, openMobileDrawer, closeMobileDrawer } = useSidebar();

  // NEW: settings modal
  const [showSettings, setShowSettings] = useState(false);

  // ⛔ Removed the mount-time bootstrap that fetched chats and loaded history.

  async function newChat(): Promise<void> {
    const id = crypto.randomUUID();
    chat.setSessionId(id);
    try { await createChat(id, "New Chat"); } catch {}
    localStorage.setItem(LS_KEY, id);
    setRefreshKey((k) => k + 1);
    chat.setInput("");
    chat.clearMetrics?.();
    await refreshFollow();
  }

  async function openSession(id: string): Promise<void> {
    if (!id) return;
    await chat.loadHistory(id);
    localStorage.setItem(LS_KEY, id);
    chat.setInput("");
    chat.clearMetrics?.();
    await refreshFollow();
  }

  // --- TWO REFRESH HELPERS ---

  // 1) Follow-to-bottom refresh (normal)
  async function refreshFollow() {
    const sid = chat.sessionIdRef.current;
    if (!sid) return;
    setAutoFollow(true);
    await chat.loadHistory(sid);
    const el = document.getElementById("chat-scroll-container");
    if (el) el.scrollTop = el.scrollHeight;
  }

async function handleCancelSessions(ids: string[]) {
  if (!ids?.length) return;

  const currentId = chat.sessionIdRef.current || "";
  const deletingActive = currentId && ids.includes(currentId);

  if (deletingActive) {
    // clear out current session instead of making a new one
    chat.setSessionId("");
    chat.setInput("");
    chat.clearMetrics?.();
    // optional: clear messages too
    chat.reset();
    localStorage.removeItem(LS_KEY);
  }

  setRefreshKey((k) => k + 1);
  try { window.dispatchEvent(new CustomEvent("chats:refresh")); } catch {}
}


  // 2) Preserve-scroll refresh (use for deletions, etc.)
  async function refreshPreserve() {
    const sid = chat.sessionIdRef.current;
    if (!sid) return;
    const el = document.getElementById("chat-scroll-container");
    const prevTop = el?.scrollTop ?? 0;
    const prevHeight = el?.scrollHeight ?? 0;

    setAutoFollow(false);
    await chat.loadHistory(sid);

    requestAnimationFrame(() => {
      if (el) {
        const newHeight = el.scrollHeight;
        el.scrollTop = prevTop + (newHeight - prevHeight);
      }
      setAutoFollow(true);
    });
  }

  // Delete by clientId(s). Immediate UI remove; API delete only for server-backed msgs.
  async function handleDeleteMessages(clientIds: string[]) {
    const sid = chat.sessionIdRef.current;
    if (!sid || !clientIds?.length) return;

    const current = chat.messages;
    const toDelete = new Set(clientIds);

    const serverIds = current
      .filter((m: any) => toDelete.has(m.id) && m.serverId != null)
      .map((m: any) => m.serverId as number);

    const remaining = current.filter((m) => !toDelete.has(m.id));

    // Optimistic local state
    if ((chat as any).setMessagesForSession) {
      (chat as any).setMessagesForSession(sid, () => remaining);
    }

    try {
      if (serverIds.length) {
        await deleteMessagesBatch(sid, serverIds);
      }

      await refreshPreserve();

      setRefreshKey((k) => k + 1);
      try { window.dispatchEvent(new CustomEvent("chats:refresh")); } catch {}

      show("Message deleted");
    } catch {
      show("Failed to delete message");
      await chat.loadHistory(sid);
      setRefreshKey((k) => k + 1);
    }
  }

  return (
    <div className="h-screen w-full flex bg-gray-50">
      {sidebarOpen && (
        <div className="hidden md:flex h-full">
          <ChatSidebar
            onOpen={openSession}
            onNew={newChat}
            refreshKey={refreshKey}
            activeId={chat.sessionIdRef.current}
            onHideSidebar={() => setSidebarOpen(false)}
            onCancelSessions={handleCancelSessions}
          />
        </div>
      )}

      <MobileDrawer
        onOpenSession={openSession}
        onNewChat={newChat}
        refreshKey={refreshKey}
        activeId={chat.sessionIdRef.current}
        openMobileDrawer={openMobileDrawer}
        closeMobileDrawer={closeMobileDrawer}
      />
      <div className="md:hidden h-14 shrink-0" />

      <div className="flex-1 min-w-0 flex flex-col">
        <DesktopHeader
          sidebarOpen={sidebarOpen}
          onShowSidebar={() => setSidebarOpen(true)}
        />

        <div className="px-3 md:px-6 pt-2">
          <div className="mx-auto max-w-3xl md:max-w-4xl flex justify-end gap-2">
            <button
              className="text-xs px-3 py-1.5 rounded border bg-white hover:bg-gray-50"
              onClick={() => setShowKnowledge(true)}
              title="Open Knowledge"
            >
              Knowledge
            </button>
            <button
              className="text-xs px-3 py-1.5 rounded border bg-white hover:bg-gray-50"
              onClick={() => setShowSettings(true)}
              title="Open Settings"
            >
              Settings
            </button>
          </div>
          <div className="mx-auto max-w-3xl md:max-w-4xl mt-2">
            <SearchTester />
          </div>
        </div>

        <div className="flex-1 min-h-0">
          <div className="h-full px-3 md:px-6">
            <div className="h-full w-full mx-auto max-w-3xl md:max-w-4xl relative">
              {/* Note: add id on the scroll container wrapper for refresh helpers */}
              <div id="chat-scroll-container" className="h-full">
                <ChatContainer
                  messages={chat.messages}
                  input={chat.input}
                  setInput={chat.setInput}
                  loading={chat.loading}
                  queued={chat.queued}
                  send={chat.send}
                  stop={chat.stop}
                  runMetrics={chat.runMetrics}
                  runJson={chat.runJson}
                  onRefreshChats={() => {}}
                  onDeleteMessages={handleDeleteMessages}
                  autoFollow={autoFollow}
                  sessionId={chat.sessionIdRef.current} // enables per-chat uploads
                />
              </div>
              <Toast message={toast} />
            </div>
          </div>
        </div>
      </div>

      {/* NEW: settings modal */}
      {showSettings && (
        <SettingsPanel
          sessionId={chat.sessionIdRef.current}
          onClose={() => setShowSettings(false)}
        />
      )}
      {showKnowledge && (
        <KnowledgePanel
          sessionId={chat.sessionIdRef.current}
          onClose={() => setShowKnowledge(false)}
          toast={show}
        />
      )}
    </div>
  );
}

# ===== frontend/src/file_read/components/Settings/BraveSearchCard.tsx =====

import { useEffect, useState } from "react";
import { getEffective, patchOverrides } from "../../data/settingsApi";

export default function BraveSearchCard() {
  const [loading, setLoading] = useState(true);
  const [, setProvider] = useState("brave");
  const [useWorker, setUseWorker] = useState(false);
  const [workerUrl, setWorkerUrl] = useState("");

  // we don’t prefill the API key for security; we only show a “present” flag
  const [hasKey, setHasKey] = useState<boolean>(false);
  const [apiKey, setApiKey] = useState("");

  useEffect(() => {
    (async () => {
      try {
        const eff = await getEffective();
        setProvider(String(eff.web_search_provider ?? "brave"));
        setWorkerUrl(String(eff.brave_worker_url ?? ""));
        setUseWorker(Boolean(eff.brave_worker_url));
        // backend will mask the key and expose only boolean presence
        setHasKey(Boolean(eff.brave_api_key_present));
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  async function save() {
    const patch: Record<string, any> = {
      web_search_provider: "brave",
      // if worker is used, clear server-side key (we’ll route via worker instead)
      brave_api_key: useWorker ? "" : apiKey,
      brave_worker_url: useWorker ? workerUrl : "",
    };
    await patchOverrides(patch);
    // don’t keep key in memory after save
    setApiKey("");
    setHasKey(!useWorker && !!patch.brave_api_key);
  }

  if (loading) return null;

  return (
    <div className="rounded-2xl p-4 border">
      <h3 className="font-semibold mb-2">Web Search (Brave)</h3>

      <div className="mb-3">
        <label className="block text-sm mb-1">Route via Cloudflare Worker</label>
        <input
          type="checkbox"
          checked={useWorker}
          onChange={(e) => setUseWorker(e.target.checked)}
        />
      </div>

      {useWorker ? (
        <div className="mb-3">
          <label className="block text-sm mb-1">Worker URL</label>
          <input
            className="w-full border rounded p-2"
            placeholder="https://your-worker.workers.dev/brave"
            value={workerUrl}
            onChange={(e) => setWorkerUrl(e.target.value)}
          />
          <p className="text-xs text-muted-foreground mt-1">
            Your Worker holds the Brave API key. The app doesn’t store it.
          </p>
        </div>
      ) : (
        <div className="mb-3">
          <label className="block text-sm mb-1">Brave API Key</label>
          <input
            className="w-full border rounded p-2"
            placeholder="X-Subscription-Token"
            type="password"
            value={apiKey}
            onChange={(e) => setApiKey(e.target.value)}
            spellCheck={false}
          />
          <p className="text-xs text-muted-foreground mt-1">
            {hasKey ? "Key is stored on the server." : "No key stored yet."}
          </p>
        </div>
      )}

      <button className="mt-2 px-3 py-2 rounded bg-black text-white" onClick={save}>
        Save
      </button>
    </div>
  );
}

# ===== frontend/src/file_read/components/Settings/WebSearchSection.tsx =====

import { useEffect, useState } from "react";
import { getEffective, patchOverrides } from "../../data/settingsApi";

export default function WebSearchSection({ onSaved }: { onSaved?: () => void }) {
  const [apiKey, setApiKey] = useState("");
  const [masked, setMasked] = useState(true);
  const [status, setStatus] = useState<null | { ok: boolean; msg: string }>(null);

  useEffect(() => {
    (async () => {
      try {
        const eff = await getEffective();
        setApiKey(eff.brave_api_key || "");
      } catch {
        // fallback if no settings
      }
    })();
  }, []);

  async function save() {
    try {
      await patchOverrides({ brave_api_key: apiKey.trim() });
      setStatus({ ok: true, msg: "Saved" });
      onSaved?.();
    } catch (e: any) {
      setStatus({ ok: false, msg: e?.message || "Failed to save" });
    }
  }

  function clearKey() {
    patchOverrides({ brave_api_key: "" });
    setApiKey("");
    setStatus({ ok: true, msg: "Key cleared" });
    onSaved?.();
  }

  const displayVal = masked && apiKey ? "•".repeat(Math.min(apiKey.length, 24)) : apiKey;

  return (
    <div className="space-y-4">
      <div className="text-sm text-gray-600">
        Enable web search via your own <b>Brave Search API</b> key. Stored in settings, not in local storage.
      </div>

      <div className="space-y-2">
        <label className="block text-sm">Brave API key</label>
        <div className="flex items-stretch gap-2">
          <input
            className="flex-1 border rounded px-3 py-2 text-sm"
            placeholder="X-Subscription-Token"
            value={displayVal}
            onChange={(e) => setApiKey(e.target.value)}
            onFocus={() => setMasked(false)}
            onBlur={() => setMasked(true)}
          />
          <button
            className="px-3 py-2 rounded border text-sm hover:bg-gray-50"
            onClick={() => setMasked((m) => !m)}
            title={masked ? "Show" : "Hide"}
          >
            {masked ? "Show" : "Hide"}
          </button>
          <button
            className="px-3 py-2 rounded border text-sm hover:bg-gray-50"
            onClick={clearKey}
            title="Clear key"
          >
            Clear
          </button>
          <button className="px-3 py-2 rounded bg-black text-white text-sm" onClick={save}>
            Save
          </button>
        </div>
        {status && (
          <div className={`text-xs ${status.ok ? "text-green-600" : "text-red-600"}`}>{status.msg}</div>
        )}
      </div>
    </div>
  );
}

# ===== frontend/src/file_read/components/SettingsPanel.tsx =====

import { useEffect, useMemo, useState } from "react";
import { useSettings } from "../hooks/useSettings";
import WebSearchSection from "../components/Settings/WebSearchSection";

type Tab =
  | "general"
  | "notifications"
  | "personalization"
  | "connectors"
  | "schedules"
  | "datacontrols"
  | "security"
  | "account"
  | "developer";

const NAV: { key: Tab; label: string }[] = [
  { key: "general", label: "General" },
  { key: "notifications", label: "Notifications" },
  { key: "personalization", label: "Personalization" },
  { key: "connectors", label: "Connectors" },
  { key: "schedules", label: "Schedules" },
  { key: "datacontrols", label: "Data controls" },
  { key: "security", label: "Security" },
  { key: "account", label: "Account" },
  { key: "developer", label: "Developer" },
];

export default function SettingsPanel({
  sessionId,
  onClose,
}: {
  sessionId?: string;
  onClose?: () => void;
}) {
  const {
    loading,
    error,
    effective,
    overrides,
    defaults,
    adaptive,
    saveOverrides,
    runAdaptive,
    reload,
  } = useSettings(sessionId);

  const [tab, setTab] = useState<Tab>("general");

  // Developer JSON views (kept from your original panel)
  const [devSubtab, setDevSubtab] = useState<"effective" | "overrides" | "adaptive" | "defaults">("effective");
  const [draft, setDraft] = useState(() => JSON.stringify(overrides ?? {}, null, 2));
  const [saveBusy, setSaveBusy] = useState(false);
  const [saveErr, setSaveErr] = useState<string | null>(null);

  useEffect(() => {
    setDraft(JSON.stringify(overrides ?? {}, null, 2));
  }, [overrides]);

  const devView = useMemo(() => {
    switch (devSubtab) {
      case "effective":
        return effective;
      case "adaptive":
        return adaptive;
      case "defaults":
        return defaults;
      case "overrides":
        return null;
    }
  }, [devSubtab, effective, adaptive, defaults]);

  async function onSaveDev(method: "patch" | "put") {
    setSaveErr(null);
    setSaveBusy(true);
    try {
      const parsed = draft.trim() ? JSON.parse(draft) : {};
      await saveOverrides(parsed, method);
    } catch (e: any) {
      setSaveErr(e?.message || "Invalid JSON or save failed");
    } finally {
      setSaveBusy(false);
    }
  }

  return (
    <div className="fixed inset-0 z-50 bg-black/40 flex items-center justify-center p-3">
      <div className="w-full max-w-5xl h-[90vh] rounded-2xl bg-white shadow-xl border overflow-hidden flex">
        {/* Sidebar */}
        <aside className="w-60 border-r bg-gray-50/60">
          <div className="px-4 py-3 text-sm font-semibold">Settings</div>
          <nav className="px-2 pb-3 space-y-1">
            {NAV.map((item) => (
              <button
                key={item.key}
                onClick={() => setTab(item.key)}
                className={`w-full text-left px-3 py-2 rounded-lg text-sm ${
                  tab === item.key
                    ? "bg-black text-white"
                    : "hover:bg-gray-100"
                }`}
              >
                {item.label}
              </button>
            ))}
          </nav>
          <div className="px-3 pt-2 mt-auto hidden md:block">
            <button
              className="w-full text-xs px-3 py-2 rounded border hover:bg-gray-100"
              onClick={() => reload()}
              title="Reload settings"
            >
              Reload
            </button>
            <button
              className="w-full mt-2 text-xs px-3 py-2 rounded border hover:bg-gray-100"
              onClick={() => runAdaptive()}
              title="Recompute adaptive"
            >
              Recompute Adaptive
            </button>
            <button
              className="w-full mt-2 text-xs px-3 py-2 rounded border hover:bg-gray-100"
              onClick={onClose}
              title="Close"
            >
              Close
            </button>
          </div>
        </aside>

        {/* Main */}
        <section className="flex-1 min-w-0 flex flex-col">
          <header className="px-5 py-4 border-b">
            <div className="text-base font-semibold capitalize">{tab.replace(/([a-z])([A-Z])/g, "$1 $2")}</div>
            {loading && <div className="text-xs text-gray-500 mt-1">Loading…</div>}
            {error && <div className="text-xs text-red-600 mt-1">{error}</div>}
          </header>

          <div className="flex-1 overflow-auto p-5">
            {tab === "general" && (
              <div className="space-y-6">
                <Section title="Appearance">
                  <Row label="Theme">
                    <select className="border rounded px-2 py-1 text-sm">
                      <option>System</option>
                      <option>Light</option>
                      <option>Dark</option>
                    </select>
                  </Row>
                  <Row label="Accent color">
                    <select className="border rounded px-2 py-1 text-sm">
                      <option>Default</option>
                      <option>Blue</option>
                      <option>Green</option>
                      <option>Purple</option>
                    </select>
                  </Row>
                  <Row label="Language">
                    <select className="border rounded px-2 py-1 text-sm">
                      <option>Auto-detect</option>
                      <option>English</option>
                      <option>Spanish</option>
                      <option>French</option>
                    </select>
                  </Row>
                </Section>

                <Section title="Web & Integrations">
                  {/* BYOK Brave search controls */}
                  <WebSearchSection
                    onSaved={() => {
                      // reflect to backend that web search is enabled (no key transmitted)
                      saveOverrides({ web_search_provider: "brave", brave_worker_url: "", brave_api_key_present: true });
                    }}
                  />
                </Section>
              </div>
            )}

            {tab === "developer" && (
              <div className="space-y-4">
                <div className="flex items-center gap-2">
                  {(["effective", "overrides", "adaptive", "defaults"] as const).map((k) => (
                    <button
                      key={k}
                      onClick={() => setDevSubtab(k)}
                      className={`text-xs mr-2 px-3 py-1.5 rounded ${
                        devSubtab === k ? "bg-black text-white" : "border hover:bg-gray-50"
                      }`}
                    >
                      {k}
                    </button>
                  ))}
                </div>

                {devSubtab !== "overrides" && (
                  <pre className="text-xs bg-gray-50 border rounded p-3 overflow-auto max-h-[60vh]">
                    {JSON.stringify(devView ?? {}, null, 2)}
                  </pre>
                )}

                {devSubtab === "overrides" && (
                  <div className="space-y-2">
                    <div className="text-xs text-gray-600">
                      Edit <code>user_overrides</code> JSON. Use <b>Patch</b> to merge or <b>Replace</b> to overwrite.
                    </div>
                    <textarea
                      value={draft}
                      onChange={(e) => setDraft(e.target.value)}
                      className="w-full h-[50vh] border rounded p-2 font-mono text-xs"
                      spellCheck={false}
                    />
                    <div className="flex items-center gap-2">
                      <button
                        className={`text-xs px-3 py-1.5 rounded ${
                          saveBusy ? "opacity-60 cursor-not-allowed" : "bg-black text-white"
                        }`}
                        disabled={saveBusy}
                        onClick={() => onSaveDev("patch")}
                        title="Deep-merge with existing overrides"
                      >
                        Save (Patch)
                      </button>
                      <button
                        className={`text-xs px-3 py-1.5 rounded border ${
                          saveBusy ? "opacity-60 cursor-not-allowed" : "hover:bg-gray-50"
                        }`}
                        disabled={saveBusy}
                        onClick={() => onSaveDev("put")}
                        title="Replace overrides entirely"
                      >
                        Save (Replace)
                      </button>
                      {saveErr && <div className="text-xs text-red-600 ml-2">{saveErr}</div>}
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Stubs for other tabs (expand later) */}
            {tab !== "general" && tab !== "developer" && (
              <div className="text-sm text-gray-500">This section is coming soon.</div>
            )}
          </div>
        </section>
      </div>
    </div>
  );
}

function Section({ title, children }: { title: string; children: React.ReactNode }) {
  return (
    <div className="rounded-2xl border p-4">
      <div className="font-semibold mb-3">{title}</div>
      {children}
    </div>
  );
}

function Row({ label, children }: { label: string; children: React.ReactNode }) {
  return (
    <div className="flex items-center gap-3 py-2">
      <div className="w-44 text-sm text-gray-600">{label}</div>
      <div className="flex-1">{children}</div>
    </div>
  );
}

# ===== frontend/src/file_read/data/chatApi.ts =====

import type { Attachment, ChatRow, ChatMessageRow} from "../types/chat";
import { request } from "../services/http";

// Spring Page<T> type
export type PageResp<T> = {
  content: T[];
  totalElements: number;
  totalPages: number;
  size: number;
  number: number;      // current page index (0-based)
  first: boolean;
  last: boolean;
  empty: boolean;
};

export function createChat(sessionId: string, title: string) {
  return request<ChatRow>("/api/chats", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionId, title }),
  });
}

export function updateChatLast(sessionId: string, lastMessage: string, title?: string) {
  return request<ChatRow>(`/api/chats/${encodeURIComponent(sessionId)}/last`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ lastMessage, title: title || "" }),
  });
}

// Legacy (unused after pagination in sidebar)
export function listChats() {
  return request<ChatRow[]>("/api/chats");
}

// NEW: paginated list
export function listChatsPage(page = 0, size = 30, ceiling?: string) {
  const qs = new URLSearchParams({ page: String(page), size: String(size) });
  if (ceiling) qs.set("ceiling", ceiling);
  return request<PageResp<ChatRow>>(`/api/chats/paged?${qs.toString()}`);
}

export function listMessages(sessionId: string) {
  return request<ChatMessageRow[]>(`/api/chats/${encodeURIComponent(sessionId)}/messages`);
}

export async function appendMessage(
  sessionId: string,
  role: "user" | "assistant",
  content: string,
  attachments?: Attachment[]
) {
  const body: any = { role, content };
  if (attachments && attachments.length) body.attachments = attachments;

  return request<ChatMessageRow>(`/api/chats/${sessionId}/messages`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(body),
  });
}

export async function deleteChatsBatch(sessionIds: string[]) {
  const data = await request<{ deleted: string[] }>("/api/chats/batch", {
    method: "DELETE",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ sessionIds }),
  });
  return data.deleted;
}

export function deleteMessage(sessionId: string, messageId: string | number) {
  return request<{ deleted: number }>(
    `/api/chats/${encodeURIComponent(sessionId)}/messages/${encodeURIComponent(String(messageId))}`,
    { method: "DELETE" }
  );
}

/** Delete a batch of messages. Backend returns { deleted: number[] } */
export function deleteMessagesBatch(sessionId: string, messageIds: (number | string)[]) {
  const ids = messageIds
    .map((id) => (typeof id === "string" ? Number(id) : id))
    .filter((n) => Number.isFinite(n)) as number[];

  return request<{ deleted: number[] }>(  // <-- number[]
    `/api/chats/${encodeURIComponent(sessionId)}/messages/batch`,
    {
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ messageIds: ids }),
    }
  );
}

# ===== frontend/src/file_read/data/ragApi.ts =====

// frontend/src/file_read/data/ragApi.ts
import { request, API_BASE } from "../services/http";

export function uploadRag(file: File, sessionId?: string, forceGlobal = false) {
  const form = new FormData();
  form.append("file", file);
  if (sessionId && !forceGlobal) form.append("sessionId", sessionId);

  return request<{ ok: boolean; added: number }>(
    "/api/rag/upload",
    { method: "POST", body: form }
  );
}

export function uploadRagWithProgress(
  file: File,
  sessionId: string,
  onProgress: (pct: number) => void,
  signal?: AbortSignal
): Promise<{ ok: boolean; added: number }> {
  return new Promise((resolve, reject) => {
    const form = new FormData();
    form.append("file", file);
    form.append("sessionId", sessionId);

    const xhr = new XMLHttpRequest();
    const url = `${API_BASE}/api/rag/upload`.replace(/([^:]\/)\/+/g, "$1");
    xhr.open("POST", url);

    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable) onProgress(Math.round((e.loaded / e.total) * 100));
    };

    xhr.onload = () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        try { resolve(JSON.parse(xhr.responseText)); }
        catch { resolve({ ok: true, added: 0 }); }
      } else {
        reject(new Error(`Upload failed (${xhr.status})`));
      }
    };

    // treat abort as a silent resolution, not an error
    xhr.onabort = () => resolve({ ok: false, added: 0 });
    xhr.onerror = () => reject(new Error("Network error"));

    if (signal) {
      if (signal.aborted) { xhr.abort(); return resolve({ ok: false, added: 0 }); }
      signal.addEventListener("abort", () => xhr.abort(), { once: true });
    }

    xhr.send(form);
  });
}


export function searchRag(query: string, opts?: {
  sessionId?: string;
  kChat?: number;
  kGlobal?: number;
  alpha?: number; // hybrid_alpha
}) {
  const body = {
    query,
    sessionId: opts?.sessionId ?? undefined,
    kChat: opts?.kChat ?? 6,
    kGlobal: opts?.kGlobal ?? 4,
    hybrid_alpha: opts?.alpha ?? 0.5,
  };

  return request<{
    hits: Array<{
      id?: string;
      score: number;
      source?: string;
      title?: string;
      text: string;
      sessionId?: string | null;
    }>;
  }>(
    "/api/rag/search",   // ✅ relative path, request() adds API_BASE
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    }
  );
}

export type UploadRow = {
  source: string;
  sessionId?: string | null;
  chunks: number;
};

export async function listUploads(sessionId?: string, scope: "all" | "session" = "all") {
  const p = new URLSearchParams();
  if (sessionId) p.set("sessionId", sessionId);
  if (scope) p.set("scope", scope);

  return request<{ uploads: UploadRow[] }>(
    `/api/rag/uploads?${p.toString()}`,
    { method: "GET" }
  );
}

export async function deleteUploadHard(source: string, sessionId?: string) {
  return request<{ ok: boolean; removed: number; remaining: number }>(
    `/api/rag/uploads/delete-hard`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ source, sessionId }),
    }
  );
}

# ===== frontend/src/file_read/data/settingsApi.ts =====

// frontend/src/file_read/data/settingsApi.ts
import { request } from "../services/http";

export function getDefaults() {
  return request<Record<string, any>>("/api/settings/defaults");
}

export function getAdaptive(sessionId?: string) {
  const qs = sessionId ? `?sessionId=${encodeURIComponent(sessionId)}` : "";
  return request<Record<string, any>>(`/api/settings/adaptive${qs}`);
}

export function getOverrides() {
  return request<Record<string, any>>("/api/settings/overrides");
}

export function getEffective(sessionId?: string) {
  const qs = sessionId ? `?sessionId=${encodeURIComponent(sessionId)}` : "";
  return request<Record<string, any>>(`/api/settings/effective${qs}`);
}

export function putOverrides(overrides: Record<string, any>) {
  return request<{ ok: boolean; overrides: any }>("/api/settings/overrides", {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(overrides), // ← send raw object
  });
}

export function patchOverrides(patch: Record<string, any>) {
  return request<{ ok: boolean; overrides: any }>("/api/settings/overrides", {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(patch), // ← send raw object
  });
}

export function recomputeAdaptive(sessionId?: string) {
  const qs = sessionId ? `?sessionId=${encodeURIComponent(sessionId)}` : "";
  return request<{ ok: boolean; adaptive: any }>(
    `/api/settings/adaptive/recompute${qs}`,
    { method: "POST" }
  );
}

# ===== frontend/src/file_read/hooks/stream/core/buffer.ts =====

// frontend/src/file_read/hooks/stream/core/buffer.ts
import type { GenMetrics, RunJson } from "../../../shared/lib/runjson";
import { extractRunJsonFromBuffer } from "../../../shared/lib/runjson";
import { STOP_SENTINEL_AT_END } from "./constants";

export type BufferStep = {
  cleanText: string;
  delta: string;
  metrics?: { json?: RunJson; flat?: GenMetrics };
};

export function processChunk(prevClean: string, rawBufIn: string): BufferStep {
  let rawBuf = rawBufIn;
  if (STOP_SENTINEL_AT_END.test(rawBuf)) {
    rawBuf = rawBuf.replace(STOP_SENTINEL_AT_END, "");
  }
  const { clean, json, flat } = extractRunJsonFromBuffer(rawBuf);
  const delta = clean.slice(prevClean.length);
  return { cleanText: clean, delta, metrics: json || flat ? { json, flat } : undefined };
}

# ===== frontend/src/file_read/hooks/stream/core/cancel.ts =====

import { postCancel } from "./network";
import { STOP_FLUSH_TIMEOUT_MS } from "./constants";

type Deps = {
  getVisibleSid: () => string;
  setLoadingFor: (sid: string, v: boolean) => void;
  setQueuedFor: (sid: string, v: boolean) => void;
  getController: () => AbortController | null;
  getReader: () => ReadableStreamDefaultReader<Uint8Array> | null;
  setCancelForSid: (sid: string | null) => void;
  isActiveSid: (sid: string) => boolean;
  dropJobsForSid: (sid: string) => void;
};

export function createCanceller(d: Deps) {
  async function cancelBySessionId(id: string) {
    // Mark as canceled so read loop can react, but DO NOT abort fetch yet.
    d.setCancelForSid(id);

    // Tell the backend to stop gracefully (flush metrics + close).
    postCancel(id).catch(() => {});

    if (d.isActiveSid(id)) {
      // Drop any queued jobs for this session, but keep loading true —
      // runStreamOnce will turn loading off in its finally after the stream ends.
      d.dropJobsForSid(id);
      d.setQueuedFor(id, false);

      // Safety net: if server doesn’t flush within timeout, hard-abort.
      window.setTimeout(() => {
        if (d.isActiveSid(id)) {
          try { d.getReader()?.cancel(); } catch {}
          try { d.getController()?.abort(); } catch {}
        }
      }, STOP_FLUSH_TIMEOUT_MS + 500);
    } else {
      // Not active: just clear queued jobs and cancel flag.
      d.dropJobsForSid(id);
      d.setQueuedFor(id, false);
      d.setCancelForSid(null);
    }
  }

  async function stopVisible() {
    const id = d.getVisibleSid();
    await cancelBySessionId(id);
  }

  return { cancelBySessionId, stopVisible };
}

# ===== frontend/src/file_read/hooks/stream/core/constants.ts =====

// frontend/src/file_read/hooks/stream/core/constants.ts
export const STOP_SENTINEL_AT_END = /(?:\r?\n)?\u23F9 stopped(?:\r?\n)?$/u;
export const STOP_FLUSH_TIMEOUT_MS = 3500;

# ===== frontend/src/file_read/hooks/stream/core/controller.ts =====

import { appendMessage } from "../../../data/chatApi";
import type { StreamController, StreamCoreOpts } from "./types";
import { createScheduler, type QueueItem } from "./queue";
import { createCanceller } from "./cancel";
import { runStreamOnce } from "./runner";
import type { Attachment } from "../../../types/chat";

export function createStreamController(opts: StreamCoreOpts): StreamController {
  let cancelForSid: string | null = null;
  let controllerRef: AbortController | null = null;
  let readerRef: ReadableStreamDefaultReader<Uint8Array> | null = null;

  const scheduler = createScheduler(async (job: QueueItem) => {
    try { opts.setQueuedFor(job.sid, false); } catch {}
    await runStreamOnce(job, {
      opts,
      getCancelForSid: () => cancelForSid,
      clearCancelIf: (sid) => { if (cancelForSid === sid) cancelForSid = null; },
      setController: (c) => { controllerRef = c; },
      setReader: (r) => { readerRef = r; },
    });
  });

  const canceller = createCanceller({
    getVisibleSid: opts.getSessionId,
    setLoadingFor: opts.setLoadingFor,
    setQueuedFor: opts.setQueuedFor,
    getController: () => controllerRef,
    getReader: () => readerRef,
    setCancelForSid: (sid) => { cancelForSid = sid; },
    isActiveSid: scheduler.isActiveSid,
    dropJobsForSid: scheduler.dropJobsForSid,
  });

  async function send(override?: string, attachments?: Attachment[]) {
    const prompt = (override ?? "").trim();
    const atts = (attachments ?? []).filter(Boolean);
    if (!prompt && atts.length === 0) return; // allow attachments-only, but not truly empty

    await opts.ensureChatCreated();
    const sid = opts.getSessionId();

    const userCid = crypto.randomUUID();
    const asstCid = crypto.randomUUID();

    // optimistic bubbles
    opts.setMessagesFor(sid, (prev) => [
      ...prev,
      { id: userCid, serverId: null, role: "user", text: prompt, attachments: atts.length ? atts : undefined },
      { id: asstCid, serverId: null, role: "assistant", text: "" },
    ]);
    opts.setInput("");

    // persist user
    appendMessage(sid, "user", prompt, atts.length ? atts : undefined)
      .then((row) => {
        if (row?.id != null) {
          opts.setServerIdFor(sid, userCid, Number(row.id));
          try {
            window.dispatchEvent(
              new CustomEvent("chats:refresh", {
                detail: {
                  sessionId: sid,
                  lastMessage: prompt,
                  updatedAt: new Date().toISOString(),
                },
              })
            );
          } catch {}
        }
      })
      .catch(() => {});

    // enqueue generation with attachments
    try { opts.setQueuedFor(sid, true); } catch {}
    scheduler.enqueue({ sid, prompt, asstId: asstCid, attachments: atts.length ? atts : undefined });
  }

  async function stop() { await canceller.stopVisible(); }
  async function cancelBySessionId(id: string) { await canceller.cancelBySessionId(id); }
  function dispose() {
    try { controllerRef?.abort(); } catch {}
    try { readerRef?.cancel(); } catch {}
    controllerRef = null; readerRef = null;
  }

  return { send, stop, cancelBySessionId, dispose };
}

# ===== frontend/src/file_read/hooks/stream/core/network.ts =====

// frontend/src/file_read/hooks/stream/core/network.ts
// (replace the existing file contents with this version)

import { buildUrl, requestRaw } from "../../../services/http";

function bearerHeaderFromLocal() {
  const h: Record<string, string> = {};
  const jwt = localStorage.getItem("local_jwt");
  if (jwt) h["Authorization"] = `Bearer ${jwt}`;
  const lic = localStorage.getItem("license_key");
  if (lic) h["x-license"] = lic;
  return h;
}

export async function postStream(body: unknown, signal: AbortSignal) {
  const url = buildUrl("/ai/generate/stream");

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    Accept: "text/event-stream",
    ...bearerHeaderFromLocal(),
  };

  console.debug("[SSE fetch]", { url, hasAuth: !!headers.Authorization }); 

  const res = await requestRaw(url, {
    method: "POST",
    headers,
    body: JSON.stringify(body),
    signal,
  });

  if (!res.ok || !res.body) {
    const t = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} ${res.statusText} ${t}`);
  }
  return res.body.getReader();
}

export async function postCancel(sessionId: string) {
  try {
    const url = buildUrl(`/ai/cancel/${encodeURIComponent(sessionId)}`);
    await requestRaw(url, { method: "POST", headers: bearerHeaderFromLocal() });
  } catch {
  }
}

# ===== frontend/src/file_read/hooks/stream/core/queue.ts =====

// frontend/src/file_read/hooks/stream/core/queue.ts
import type { Attachment } from "../../../types/chat";

export type QueueItem = {
  sid: string;
  prompt: string;              // may be empty when attachments-only
  asstId: string;              // client id of the assistant bubble to stream into
  attachments?: Attachment[];  // optional attachments for this turn
};

export type RunJob = (job: QueueItem) => Promise<void>;

export function createScheduler(runJob: RunJob) {
  const q: QueueItem[] = [];
  let active: { sid: string } | null = null;

  async function startNext() {
    if (active || q.length === 0) return;
    const job = q.shift()!;
    active = { sid: job.sid };
    try {
      await runJob(job);
    } finally {
      active = null;
      if (q.length) void startNext();
    }
  }

  return {
    enqueue(job: QueueItem) {
      q.push(job);
      void startNext();
    },
    isActiveSid: (sid: string) => active?.sid === sid,
    dropJobsForSid(sid: string) {
      for (let i = q.length - 1; i >= 0; i--) {
        if (q[i].sid === sid) q.splice(i, 1);
      }
    },
    getActiveSid: () => active?.sid ?? null,
  };
}

# ===== frontend/src/file_read/hooks/stream/core/runner.ts =====

// frontend/src/file_read/hooks/stream/core/runner.ts
import { postStream } from "./network";
import { ensureAssistantPlaceholder, snapshotPendingAssistant } from "./updater";
import type { ChatMsg } from "../../../types/chat";
import type { RunJson, GenMetrics } from "../../../shared/lib/runjson";
import { readStreamLoop } from "./runner_stream";
import {
  pinLiveMetricsToSession,
  pinLiveMetricsToBubble,
  pinFallbackToSessionAndBubble,
} from "./runner_metrics";
import { persistAssistantTurn } from "./runner_persist";
import type { QueueItem } from "./queue";
import { listChatsPage } from "../../../data/chatApi";


export type RunnerDeps = {
  opts: {
    ensureChatCreated: () => Promise<void>;
    getSessionId: () => string;
    getMessagesFor: (sid: string) => ChatMsg[];
    setMessagesFor: (sid: string, fn: (prev: ChatMsg[]) => ChatMsg[]) => void;
    setInput: (v: string) => void;
    setLoadingFor: (sid: string, v: boolean) => void;
    setQueuedFor: (sid: string, v: boolean) => void;
    resetMetricsFor: (sid: string) => void;
    setMetricsFor: (sid: string, json?: RunJson, flat?: GenMetrics) => void;
    setMetricsFallbackFor: (sid: string, reason: string, text: string) => void;
    onRetitle: (sid: string, finalText: string) => Promise<void>;
    setServerIdFor: (sid: string, clientId: string, serverId: number) => void;
  };
  getCancelForSid: () => string | null;
  clearCancelIf: (sid: string) => void;
  setController: (c: AbortController | null) => void;
  setReader: (r: ReadableStreamDefaultReader<Uint8Array> | null) => void;
};

export async function runStreamOnce(job: QueueItem, d: RunnerDeps) {
  const { sid, prompt, asstId, attachments } = job;
  const { opts } = d;
  const wasCanceled = () => d.getCancelForSid() === sid;

  opts.resetMetricsFor(sid);
  opts.setLoadingFor(sid, true);

  ensureAssistantPlaceholder(
    { getMessagesFor: opts.getMessagesFor, setMessagesFor: opts.setMessagesFor },
    sid,
    asstId
  );

  const MAX_HISTORY = 10;
  const history = opts
    .getMessagesFor(sid)
    .slice(-MAX_HISTORY)
    .map((m) => ({
      role: m.role,
      content: m.text || "",
      attachments: m.attachments && m.attachments.length ? m.attachments : undefined,
    }))
    .filter(
      (m) =>
        (m.content && m.content.trim().length > 0) ||
        (m.attachments && m.attachments.length > 0)
    );

  const userTurn = {
    role: "user" as const,
    content: prompt,
    attachments: attachments && attachments.length ? attachments : undefined,
  };

  const controller = new AbortController();
  d.setController(controller);
  let reader: ReadableStreamDefaultReader<Uint8Array> | null = null;

  try {
    reader = await postStream(
      { sessionId: sid, messages: [...history, userTurn] },
      controller.signal
    );
    d.setReader(reader);

    const { finalText, gotMetrics, lastRunJson } = await readStreamLoop(reader, {
      wasCanceled,
      onDelta: (delta) => {
        opts.setMessagesFor(sid, (prev) => {
          const idx = prev.findIndex((m) => m.id === asstId);
          if (idx === -1) return prev;
          const next = [...prev];
          next[idx] = { ...next[idx], text: (next[idx].text || "") + delta };
          return next;
        });
      },
      onMetrics: (json, flat) => {
        pinLiveMetricsToSession(opts, sid, json, flat);
        pinLiveMetricsToBubble(opts, sid, asstId, json, flat);
      },
      onCancelTimeout: (cleanSoFar) => {
        opts.setMetricsFallbackFor(sid, "user_cancel_timeout", cleanSoFar);
      },
    });

    let persistJson: RunJson | null = gotMetrics ? lastRunJson : null;

    if (!gotMetrics) {
      const reason = wasCanceled() ? "user_cancel" : "end_of_stream_no_metrics";
      const fallback = pinFallbackToSessionAndBubble(opts, sid, asstId, reason, finalText);
      if (!wasCanceled()) persistJson = fallback;
    }

    if (!wasCanceled() && finalText.trim()) {
      const newServerId = await persistAssistantTurn(sid, finalText, persistJson);
      if (newServerId != null) {
        opts.setServerIdFor(sid, asstId, newServerId);
      }

      try { await opts.onRetitle(sid, finalText); } catch {}
      try {
        window.dispatchEvent(
          new CustomEvent("chats:refresh", {
            detail: {
              sessionId: sid,
              lastMessage: finalText,
              updatedAt: new Date().toISOString(),
            },
          })
        );
      } catch {}

      const pokeForTitle = (delayMs: number) => {
        window.setTimeout(async () => {
          try {
            const ceil = new Date().toISOString();
            const page = await listChatsPage(0, 30, ceil);
            const row = page.content.find((r: any) => r.sessionId === sid);
            if (row?.title) {
              window.dispatchEvent(
                new CustomEvent("chats:refresh", {
                  detail: {
                    sessionId: sid,
                    title: row.title,
                    updatedAt: row.updatedAt,
                  },
                })
              );
            }
          } catch {}
        }, delayMs);
      };
      pokeForTitle(3000);
      pokeForTitle(8000);
    }
  } catch (e: any) {
    const localAbort =
      e?.name === "AbortError" && (wasCanceled() || controller.signal.aborted);
    const reason = localAbort ? "client_abort_after_stop" : e?.name || "client_error";

    const last = snapshotPendingAssistant(opts.getMessagesFor(sid));
    opts.setMetricsFallbackFor(sid, reason, last);
    pinFallbackToSessionAndBubble(opts, sid, asstId, reason, last);

    opts.setMessagesFor(sid, (prev) => {
      const end = prev[prev.length - 1];
      if (end?.role === "assistant" && !end.text.trim()) {
        return prev.map((m, i) =>
          i === prev.length - 1 ? { ...m, text: "[stream error]" } : m
        );
      }
      return prev;
    });
  } finally {
    if (d.getCancelForSid() === sid) d.clearCancelIf(sid);
    opts.setLoadingFor(sid, false);
    d.setController(null);
    d.setReader(null);
  }
}

# ===== frontend/src/file_read/hooks/stream/core/runner_metrics.ts =====

import type { RunJson, GenMetrics } from "../../../shared/lib/runjson";
import type { ChatMsg } from "../../../types/chat";

type Opts = {
  setMetricsFor: (sid: string, json?: RunJson, flat?: GenMetrics) => void;
  setMessagesFor: (sid: string, fn: (prev: ChatMsg[]) => ChatMsg[]) => void;
  setMetricsFallbackFor: (sid: string, reason: string, text: string) => void;
};

export function pinLiveMetricsToSession(
  opts: Opts,
  sid: string,
  json?: RunJson,
  flat?: GenMetrics
) {
  opts.setMetricsFor(sid, json, flat);
}

export function pinLiveMetricsToBubble(
  opts: Opts,
  sid: string,
  asstId: string,
  json?: RunJson,
  flat?: GenMetrics
) {
  opts.setMessagesFor(sid, (prev) =>
    prev.map((m) =>
      m.id === asstId
        ? { ...m, meta: { ...(m.meta ?? {}), runJson: json ?? m.meta?.runJson, flat: flat ?? m.meta?.flat } }
        : m
    )
  );
}

/** Also returns the synthesized RunJson so caller can persist if needed. */
export function pinFallbackToSessionAndBubble(
  opts: Opts,
  sid: string,
  asstId: string,
  reason: string,
  finalText: string
): RunJson {
  const json: RunJson = {
    stats: {
      stopReason: reason,
      tokensPerSecond: null,
      timeToFirstTokenSec: null,
      totalTimeSec: null,
      promptTokensCount: null,
      predictedTokensCount: finalText ? finalText.length : 0,
      totalTokensCount: null,
    },
  };
  const flat: GenMetrics = {
    stop_reason: reason,
    tok_per_sec: null,
    ttft_ms: null,
    output_tokens: null,
    input_tokens_est: null,
    total_tokens_est: null,
  };

  opts.setMetricsFallbackFor(sid, reason, finalText);
  opts.setMessagesFor(sid, (prev) =>
    prev.map((m) =>
      m.id === asstId ? { ...m, meta: { ...(m.meta ?? {}), runJson: json, flat } } : m
    )
  );
  return json;
}

# ===== frontend/src/file_read/hooks/stream/core/runner_persist.ts =====

import { appendMessage, updateChatLast } from "../../../data/chatApi";
import type { RunJson } from "../../../shared/lib/runjson";
import { MET_START, MET_END } from "../../../shared/lib/runjson";

/**
 * Persist assistant turn; returns the new server message id (or null).
 */
export async function persistAssistantTurn(
  sid: string,
  finalText: string,
  json: RunJson | null
): Promise<number | null> {
  let toPersist = finalText;
  if (json) {
    toPersist = `${finalText}\n${MET_START}\n${JSON.stringify(json)}\n${MET_END}\n`;
  }
  try {
    const row = await appendMessage(sid, "assistant", toPersist);
    await updateChatLast(sid, finalText, "").catch(() => {});
    return row?.id != null ? Number(row.id) : null;
  } catch {
    return null;
  }
}

# ===== frontend/src/file_read/hooks/stream/core/runner_stream.ts =====

import { STOP_FLUSH_TIMEOUT_MS } from "./constants";
import type { RunJson, GenMetrics } from "../../../shared/lib/runjson";
import { processChunk } from "./buffer";

type LoopDeps = {
  wasCanceled: () => boolean;
  onDelta: (delta: string, cleanSoFar: string) => void;
  onMetrics: (json?: RunJson, flat?: GenMetrics) => void;
  onCancelTimeout: (cleanSoFar: string) => void;
};

export async function readStreamLoop(
  reader: ReadableStreamDefaultReader<Uint8Array>,
  d: LoopDeps
): Promise<{ finalText: string; gotMetrics: boolean; lastRunJson: RunJson | null }> {
  const decoder = new TextDecoder();
  let rawBuf = "";
  let cleanSoFar = "";
  let gotMetrics = false;
  let lastRunJson: RunJson | null = null;
  let stopTimeout: number | null = null;

  while (true) {
    const { value, done } = await reader.read();
    if (done) break;

    if (value) {
      rawBuf += decoder.decode(value, { stream: true });
      const step = processChunk(cleanSoFar, rawBuf);

      if (step.metrics) {
        gotMetrics = true;
        if (step.metrics.json) lastRunJson = step.metrics.json;
        d.onMetrics(step.metrics.json, step.metrics.flat);
      }
      if (step.delta) {
        cleanSoFar = step.cleanText;
        d.onDelta(step.delta, cleanSoFar);
      }
    }

    // If user canceled, schedule a final flush check, but DO NOT break early
    if (d.wasCanceled() && stopTimeout === null) {
      stopTimeout = window.setTimeout(() => {
        if (!gotMetrics) d.onCancelTimeout(cleanSoFar);
      }, STOP_FLUSH_TIMEOUT_MS) as unknown as number;
    }
  }

  if (stopTimeout !== null) {
    // If we scheduled a timeout but finished before it fired, synthesize now.
    if (!gotMetrics && d.wasCanceled()) {
      d.onCancelTimeout(cleanSoFar);
    }
    window.clearTimeout(stopTimeout);
  }

  return { finalText: cleanSoFar, gotMetrics, lastRunJson };
}

# ===== frontend/src/file_read/hooks/stream/core/types.ts =====

// frontend/src/file_read/hooks/stream/core/types.ts
import type { ChatMsg, Attachment } from "../../../types/chat";
import type { GenMetrics, RunJson } from "../../../shared/lib/runjson";

export type MsgAccessor = {
  getMessagesFor: (sessionId: string) => ChatMsg[];
  setMessagesFor: (sessionId: string, updater: (prev: ChatMsg[]) => ChatMsg[]) => void;
};

export type UiHooks = {
  setInput: (v: string) => void;
  setLoadingFor: (sessionId: string, v: boolean) => void;
  setQueuedFor: (sessionId: string, v: boolean) => void;
  setMetricsFor: (sessionId: string, json?: RunJson, flat?: GenMetrics) => void;
  setMetricsFallbackFor: (sessionId: string, reason: string, partialOut: string) => void;

  /** patch the server id for a bubble identified by clientId */
  setServerIdFor: (sid: string, clientId: string, serverId: number) => void;
};

export type SessionPlumbing = {
  getSessionId: () => string;
  ensureChatCreated: () => Promise<void>;
  onRetitle: (sessionId: string, latestAssistant: string) => Promise<void>;
  resetMetricsFor: (sessionId: string) => void;
};

export type StreamCoreOpts = MsgAccessor & UiHooks & SessionPlumbing;

export type StreamController = {
  /** text can be empty if attachments are present */
  send: (override?: string, attachments?: Attachment[]) => Promise<void>;
  stop: () => Promise<void>;
  cancelBySessionId: (sid: string) => Promise<void>;
  dispose: () => void;
};

# ===== frontend/src/file_read/hooks/stream/core/updater.ts =====

import type { ChatMsg } from "../../../types/chat";
import type { MsgAccessor } from "./types";

export function appendAssistantDelta(
  access: MsgAccessor,
  sessionId: string,
  asstId: string,
  delta: string
) {
  if (!delta) return;
  access.setMessagesFor(sessionId, (prev) => {
    const idx = prev.findIndex((m) => m.id === asstId);
    if (idx === -1) return prev;
    const next = [...prev];
    const cur = next[idx];
    next[idx] = { ...cur, text: (cur.text || "") + delta };
    return next;
  });
}

export function ensureAssistantPlaceholder(
  access: MsgAccessor,
  sessionId: string,
  asstId: string
) {
  access.setMessagesFor(sessionId, (prev) => {
    const idx = prev.findIndex((m) => m.id === asstId);
    if (idx !== -1) return prev;
    return [...prev, { id: asstId, serverId: null, role: "assistant", text: "" } as ChatMsg];
  });
}

export function snapshotPendingAssistant(msgs: ChatMsg[]): string {
  if (!msgs.length) return "";
  const last = msgs[msgs.length - 1];
  return last.role === "assistant" ? last.text : "";
}

# ===== frontend/src/file_read/hooks/useAttachmentUploads.ts =====

import { useCallback, useMemo, useRef, useState } from "react";
import type { Attachment } from "../types/chat";
import { requestRaw } from "../services/http";

// Local UI id for keys & removal
const makeUiId = () =>
  Math.random().toString(36).slice(2) + "-" + Date.now().toString(36);

export type UIAttachment = {
  uiId: string;
  name: string;

  // UI state
  status: "uploading" | "ready" | "error";
  pct: number;           // 0..100
  error?: string;

  // Optional extras
  size?: number;
  mime?: string;
  url?: string;
  serverId?: string;     // if backend returns an id
};

type ReturnShape = {
  atts: UIAttachment[];
  addFiles: (files: FileList | File[]) => Promise<void>;
  removeAtt: (arg: string | UIAttachment) => void; // accepts uiId or whole object
  anyUploading: boolean;
  anyReady: boolean;
  attachmentsForPost: () => Attachment[];          // what your API expects
  reset: () => void;
};

export function useAttachmentUploads(
  sessionId?: string,
  onRefreshChats?: () => void
): ReturnShape {
  const [atts, setAtts] = useState<UIAttachment[]>([]);
  const triedEndpoints = useRef<string[] | null>(null);

  const detectAndUpload = useCallback(
    async (file: File): Promise<UIAttachment> => {
      const endpoints =
        triedEndpoints.current ??
        ["/api/rag/upload", "/api/rag/uploads", "/api/uploads"];

      let lastErr: unknown = null;

      for (const ep of endpoints) {
        try {
          const fd = new FormData();
          fd.append("file", file);
          if (sessionId) fd.append("sessionId", sessionId);

          const res = await requestRaw(ep, { method: "POST", body: fd });
          const text = await res.text();
          if (!res.ok) throw new Error(`Upload failed (${res.status}) ${res.statusText} ${text || ""}`.trim());

          let data: any = {};
          try { data = text ? JSON.parse(text) : {}; } catch {}

          const ui: UIAttachment = {
            uiId: makeUiId(),
            name: (data.name ?? file.name) as string,
            status: "ready",
            pct: 100,
            size: Number(data.size ?? file.size) || file.size,
            mime: (data.contentType ?? data.mime ?? file.type) as string,
            url: (data.url ?? data.location ?? undefined) as string | undefined,
            serverId: (data.id ?? data.fileId ?? data.uploadId)?.toString(),
          };

          if (!triedEndpoints.current) {
            triedEndpoints.current = [ep, ...endpoints.filter((e) => e !== ep)];
          }
          return ui;
        } catch (e) {
          lastErr = e;
        }
      }
      throw lastErr ?? new Error("No working upload endpoint found");
    },
    [sessionId]
  );

  const addFiles = useCallback(
    async (files: FileList | File[]) => {
      const arr = Array.from(files);
      if (arr.length === 0) return;

      // optimistic rows
      const optimistic: UIAttachment[] = arr.map((f) => ({
        uiId: makeUiId(),
        name: f.name,
        status: "uploading",
        pct: 0,
        size: f.size,
        mime: f.type,
      }));
      setAtts((cur) => [...cur, ...optimistic]);

      await Promise.all(
        arr.map(async (file, i) => {
          const tempUiId = optimistic[i].uiId;
          try {
            const finalUi: UIAttachment = sessionId
              ? await detectAndUpload(file)
              : {
                  uiId: makeUiId(),
                  name: file.name,
                  status: "ready",
                  pct: 100,
                  size: file.size,
                  mime: file.type,
                };

            setAtts((cur) => cur.map((a) => (a.uiId === tempUiId ? finalUi : a)));
          } catch (e: any) {
            setAtts((cur) =>
              cur.map((a) =>
                a.uiId === tempUiId
                  ? { ...a, status: "error", pct: 0, error: e?.message ?? "Upload failed." }
                  : a
              )
            );
          }
        })
      );

      onRefreshChats?.();
    },
    [detectAndUpload, onRefreshChats, sessionId]
  );

  const removeAtt = useCallback((arg: string | UIAttachment) => {
    const uiId = typeof arg === "string" ? arg : arg.uiId;
    setAtts((cur) => cur.filter((a) => a.uiId !== uiId));
  }, []);

  const anyUploading = useMemo(() => atts.some((a) => a.status === "uploading"), [atts]);
  const anyReady = useMemo(() => atts.some((a) => a.status === "ready"), [atts]);

  const attachmentsForPost = useCallback((): Attachment[] => {
    return atts
      .filter((a) => a.status === "ready")
      .map<Attachment>((a) => {
        const out = { name: a.name } as Attachment;
        // If your Attachment type supports these, you can add them:
        // (out as any).url = a.url;
        // (out as any).contentType = a.mime;
        // (out as any).bytes = a.size;
        // (out as a